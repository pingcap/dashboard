// tslint:disable
/**
 * Dashboard API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ClusterinfoAlertManagerInfo
 */
export interface ClusterinfoAlertManagerInfo {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoAlertManagerInfo
     */
    binary_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoAlertManagerInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoAlertManagerInfo
     */
    port?: number;
}
/**
 * 
 * @export
 * @interface ClusterinfoClusterInfo
 */
export interface ClusterinfoClusterInfo {
    /**
     * 
     * @type {ClusterinfoAlertManagerInfo}
     * @memberof ClusterinfoClusterInfo
     */
    alert_manager?: ClusterinfoAlertManagerInfo;
    /**
     * 
     * @type {ClusterinfoGrafanaInfo}
     * @memberof ClusterinfoClusterInfo
     */
    grafana?: ClusterinfoGrafanaInfo;
    /**
     * 
     * @type {ClusterinfoClusterInfoPd}
     * @memberof ClusterinfoClusterInfo
     */
    pd?: ClusterinfoClusterInfoPd;
    /**
     * 
     * @type {ClusterinfoClusterInfoTidb}
     * @memberof ClusterinfoClusterInfo
     */
    tidb?: ClusterinfoClusterInfoTidb;
    /**
     * 
     * @type {ClusterinfoClusterInfoTikv}
     * @memberof ClusterinfoClusterInfo
     */
    tikv?: ClusterinfoClusterInfoTikv;
}
/**
 * 
 * @export
 * @interface ClusterinfoClusterInfoPd
 */
export interface ClusterinfoClusterInfoPd {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoClusterInfoPd
     */
    err?: string;
    /**
     * 
     * @type {Array<ClusterinfoPDInfo>}
     * @memberof ClusterinfoClusterInfoPd
     */
    nodes?: Array<ClusterinfoPDInfo>;
}
/**
 * 
 * @export
 * @interface ClusterinfoClusterInfoTidb
 */
export interface ClusterinfoClusterInfoTidb {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoClusterInfoTidb
     */
    err?: string;
    /**
     * 
     * @type {Array<ClusterinfoTiDBInfo>}
     * @memberof ClusterinfoClusterInfoTidb
     */
    nodes?: Array<ClusterinfoTiDBInfo>;
}
/**
 * 
 * @export
 * @interface ClusterinfoClusterInfoTikv
 */
export interface ClusterinfoClusterInfoTikv {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoClusterInfoTikv
     */
    err?: string;
    /**
     * 
     * @type {Array<ClusterinfoTiKVInfo>}
     * @memberof ClusterinfoClusterInfoTikv
     */
    nodes?: Array<ClusterinfoTiKVInfo>;
}
/**
 * 
 * @export
 * @interface ClusterinfoGrafanaInfo
 */
export interface ClusterinfoGrafanaInfo {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoGrafanaInfo
     */
    binary_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoGrafanaInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoGrafanaInfo
     */
    port?: number;
}
/**
 * 
 * @export
 * @interface ClusterinfoPDInfo
 */
export interface ClusterinfoPDInfo {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoPDInfo
     */
    deploy_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoPDInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoPDInfo
     */
    port?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoPDInfo
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoPDInfo
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface ClusterinfoTiDBInfo
 */
export interface ClusterinfoTiDBInfo {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiDBInfo
     */
    binary_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiDBInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiDBInfo
     */
    port?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiDBInfo
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiDBInfo
     */
    status_port?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiDBInfo
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface ClusterinfoTiKVInfo
 */
export interface ClusterinfoTiKVInfo {
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiKVInfo
     */
    binary_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiKVInfo
     */
    ip?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ClusterinfoTiKVInfo
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiKVInfo
     */
    port?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiKVInfo
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoTiKVInfo
     */
    status_port?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterinfoTiKVInfo
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface DecoratorLabelKey
 */
export interface DecoratorLabelKey {
    /**
     * 
     * @type {string}
     * @memberof DecoratorLabelKey
     */
    key: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DecoratorLabelKey
     */
    labels: Array<string>;
}
/**
 * 
 * @export
 * @interface DiagnoseReport
 */
export interface DiagnoseReport {
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    compare_end_time?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    compare_start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    deletedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    end_time?: string;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseReport
     */
    id?: number;
    /**
     * 0~100
     * @type {number}
     * @memberof DiagnoseReport
     */
    progress?: number;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface DiagnoseReportRes
 */
export interface DiagnoseReportRes {
    /**
     * 
     * @type {number}
     * @memberof DiagnoseReportRes
     */
    report_id?: number;
}
/**
 * 
 * @export
 * @interface DiagnosticspbSearchLogRequest
 */
export interface DiagnosticspbSearchLogRequest {
    /**
     * 
     * @type {number}
     * @memberof DiagnosticspbSearchLogRequest
     */
    end_time?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DiagnosticspbSearchLogRequest
     */
    levels?: Array<number>;
    /**
     * We use a string array to represent multiple CNF pattern sceniaor like: SELECT * FROM t WHERE c LIKE \'%s%\' and c REGEXP \'.*a.*\' because Golang and Rust don\'t support perl-like (?=re1)(?=re2)
     * @type {Array<string>}
     * @memberof DiagnosticspbSearchLogRequest
     */
    patterns?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DiagnosticspbSearchLogRequest
     */
    start_time?: number;
}
/**
 * 
 * @export
 * @interface InfoInfoResponse
 */
export interface InfoInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof InfoInfoResponse
     */
    pd_end_point?: string;
    /**
     * 
     * @type {UtilsVersionInfo}
     * @memberof InfoInfoResponse
     */
    version?: UtilsVersionInfo;
}
/**
 * 
 * @export
 * @interface InfoWhoAmIResponse
 */
export interface InfoWhoAmIResponse {
    /**
     * 
     * @type {string}
     * @memberof InfoWhoAmIResponse
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface LogsearchCreateTaskGroupRequest
 */
export interface LogsearchCreateTaskGroupRequest {
    /**
     * 
     * @type {DiagnosticspbSearchLogRequest}
     * @memberof LogsearchCreateTaskGroupRequest
     */
    request: DiagnosticspbSearchLogRequest;
    /**
     * 
     * @type {Array<LogsearchSearchTarget>}
     * @memberof LogsearchCreateTaskGroupRequest
     */
    search_targets: Array<LogsearchSearchTarget>;
}
/**
 * 
 * @export
 * @interface LogsearchPreviewModel
 */
export interface LogsearchPreviewModel {
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    level?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchPreviewModel
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    task_group_id?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    task_id?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface LogsearchSearchLogRequest
 */
export interface LogsearchSearchLogRequest {
}
/**
 * 
 * @export
 * @interface LogsearchSearchTarget
 */
export interface LogsearchSearchTarget {
    /**
     * 
     * @type {string}
     * @memberof LogsearchSearchTarget
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchTarget
     */
    kind?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchTarget
     */
    port?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchTarget
     */
    status_port?: number;
}
/**
 * 
 * @export
 * @interface LogsearchTaskGroupModel
 */
export interface LogsearchTaskGroupModel {
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskGroupModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskGroupModel
     */
    log_store_dir?: string;
    /**
     * 
     * @type {DiagnosticspbSearchLogRequest}
     * @memberof LogsearchTaskGroupModel
     */
    search_request?: DiagnosticspbSearchLogRequest;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskGroupModel
     */
    state?: number;
}
/**
 * 
 * @export
 * @interface LogsearchTaskGroupResponse
 */
export interface LogsearchTaskGroupResponse {
    /**
     * 
     * @type {LogsearchTaskGroupModel}
     * @memberof LogsearchTaskGroupResponse
     */
    task_group?: LogsearchTaskGroupModel;
    /**
     * 
     * @type {Array<LogsearchTaskModel>}
     * @memberof LogsearchTaskGroupResponse
     */
    tasks?: Array<LogsearchTaskModel>;
}
/**
 * 
 * @export
 * @interface LogsearchTaskModel
 */
export interface LogsearchTaskModel {
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskModel
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskModel
     */
    log_store_path?: string;
    /**
     * 
     * @type {LogsearchSearchTarget}
     * @memberof LogsearchTaskModel
     */
    search_target?: LogsearchSearchTarget;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    state?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    task_group_id?: number;
}
/**
 * 
 * @export
 * @interface MatrixMatrix
 */
export interface MatrixMatrix {
    /**
     * 
     * @type {{ [key: string]: Array<Array<number>>; }}
     * @memberof MatrixMatrix
     */
    data: { [key: string]: Array<Array<number>>; };
    /**
     * 
     * @type {Array<DecoratorLabelKey>}
     * @memberof MatrixMatrix
     */
    keyAxis: Array<DecoratorLabelKey>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MatrixMatrix
     */
    timeAxis: Array<number>;
}
/**
 * 
 * @export
 * @interface ProfilingGroupDetailResponse
 */
export interface ProfilingGroupDetailResponse {
    /**
     * 
     * @type {number}
     * @memberof ProfilingGroupDetailResponse
     */
    server_time?: number;
    /**
     * 
     * @type {ProfilingTaskGroupModel}
     * @memberof ProfilingGroupDetailResponse
     */
    task_group_status?: ProfilingTaskGroupModel;
    /**
     * 
     * @type {Array<ProfilingTaskModel>}
     * @memberof ProfilingGroupDetailResponse
     */
    tasks_status?: Array<ProfilingTaskModel>;
}
/**
 * 
 * @export
 * @interface ProfilingStartRequest
 */
export interface ProfilingStartRequest {
    /**
     * 
     * @type {number}
     * @memberof ProfilingStartRequest
     */
    collection_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingStartRequest
     */
    duration_secs?: number;
    /**
     * 
     * @type {Array<UtilsRequestTargetNode>}
     * @memberof ProfilingStartRequest
     */
    targets?: Array<UtilsRequestTargetNode>;
}
/**
 * 
 * @export
 * @interface ProfilingTaskGroupModel
 */
export interface ProfilingTaskGroupModel {
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    profile_duration_secs?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    started_at?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    state?: number;
    /**
     * 
     * @type {UtilsRequestTargetStatistics}
     * @memberof ProfilingTaskGroupModel
     */
    target_stats?: UtilsRequestTargetStatistics;
}
/**
 * 
 * @export
 * @interface ProfilingTaskModel
 */
export interface ProfilingTaskModel {
    /**
     * 
     * @type {string}
     * @memberof ProfilingTaskModel
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilingTaskModel
     */
    file_path?: string;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    id?: number;
    /**
     * The start running time, reset when retry. Used to estimate approximate profiling progress.
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    started_at?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    state?: number;
    /**
     * 
     * @type {UtilsRequestTargetNode}
     * @memberof ProfilingTaskModel
     */
    target?: UtilsRequestTargetNode;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    task_group_id?: number;
}
/**
 * 
 * @export
 * @interface StatementDetail
 */
export interface StatementDetail {
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    agg_table_names?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementDetail
     */
    avg_affected_rows?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementDetail
     */
    avg_total_keys?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    digest?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    digest_text?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementDetail
     */
    exec_count?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    last_seen?: string;
    /**
     * 
     * @type {Array<StatementPlan>}
     * @memberof StatementDetail
     */
    plans?: Array<StatementPlan>;
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    query_sample_text?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementDetail
     */
    schema_name?: string;
    /**
     * Schemas is extracted from table_names column table_names example: \"d1.t1,d2.t2\", we extract the \"d1,d2\" as schemas
     * @type {string}
     * @memberof StatementDetail
     */
    schemas?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementDetail
     */
    sum_latency?: number;
}
/**
 * 
 * @export
 * @interface StatementNode
 */
export interface StatementNode {
    /**
     * 
     * @type {string}
     * @memberof StatementNode
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    avg_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    avg_mem?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    exec_count?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    max_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    sum_backoff_times?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementNode
     */
    sum_latency?: number;
}
/**
 * 
 * @export
 * @interface StatementOverview
 */
export interface StatementOverview {
    /**
     * 
     * @type {string}
     * @memberof StatementOverview
     */
    agg_table_names?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementOverview
     */
    avg_affected_rows?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementOverview
     */
    avg_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementOverview
     */
    avg_mem?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementOverview
     */
    digest?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementOverview
     */
    digest_text?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementOverview
     */
    exec_count?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementOverview
     */
    schema_name?: string;
    /**
     * Schemas is extracted from table_names column table_names example: \"d1.t1,d2.t2\", we extract the \"d1,d2\" as schemas
     * @type {string}
     * @memberof StatementOverview
     */
    schemas?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementOverview
     */
    sum_latency?: number;
}
/**
 * 
 * @export
 * @interface StatementPlan
 */
export interface StatementPlan {
    /**
     * 
     * @type {string}
     * @memberof StatementPlan
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementPlan
     */
    digest?: string;
}
/**
 * 
 * @export
 * @interface StatementTimeRange
 */
export interface StatementTimeRange {
    /**
     * 
     * @type {string}
     * @memberof StatementTimeRange
     */
    begin_time?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementTimeRange
     */
    end_time?: string;
}
/**
 * 
 * @export
 * @interface UserAuthenticateForm
 */
export interface UserAuthenticateForm {
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticateForm
     */
    is_tidb_auth: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticateForm
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticateForm
     */
    username: string;
}
/**
 * 
 * @export
 * @interface UserTokenResponse
 */
export interface UserTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof UserTokenResponse
     */
    expire?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTokenResponse
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface UtilsAPIError
 */
export interface UtilsAPIError {
    /**
     * 
     * @type {string}
     * @memberof UtilsAPIError
     */
    code?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UtilsAPIError
     */
    error?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UtilsAPIError
     */
    full_text?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsAPIError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface UtilsRequestTargetNode
 */
export interface UtilsRequestTargetNode {
    /**
     * 
     * @type {string}
     * @memberof UtilsRequestTargetNode
     */
    display_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsRequestTargetNode
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsRequestTargetNode
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof UtilsRequestTargetNode
     */
    port?: number;
}
/**
 * 
 * @export
 * @interface UtilsRequestTargetStatistics
 */
export interface UtilsRequestTargetStatistics {
    /**
     * 
     * @type {number}
     * @memberof UtilsRequestTargetStatistics
     */
    num_pd_nodes?: number;
    /**
     * 
     * @type {number}
     * @memberof UtilsRequestTargetStatistics
     */
    num_tidb_nodes?: number;
    /**
     * 
     * @type {number}
     * @memberof UtilsRequestTargetStatistics
     */
    num_tikv_nodes?: number;
}
/**
 * 
 * @export
 * @interface UtilsVersionInfo
 */
export interface UtilsVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof UtilsVersionInfo
     */
    build_git_branch?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsVersionInfo
     */
    build_git_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsVersionInfo
     */
    build_time?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilsVersionInfo
     */
    release_version?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup(groupId: string, options: any = {}): RequestArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling cancelProfilingGroup.');
            }
            const localVarPath = `/profiling/group/cancel/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup(groupId: string, options: any = {}): RequestArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling deleteProfilingGroup.');
            }
            const localVarPath = `/profiling/group/delete/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdGet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling diagnoseReportsIdGet.');
            }
            const localVarPath = `/diagnose/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling diagnoseReportsIdStatusGet.');
            }
            const localVarPath = `/diagnose/reports/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} start_time start time of the report
         * @param {string} end_time end time of the report
         * @param {string} [c_start_time] compared start time of the report
         * @param {string} [c_end_time] compared end time of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost(start_time: string, end_time: string, c_start_time?: string, c_end_time?: string, options: any = {}): RequestArgs {
            // verify required parameter 'start_time' is not null or undefined
            if (start_time === null || start_time === undefined) {
                throw new RequiredError('start_time','Required parameter start_time was null or undefined when calling diagnoseReportsPost.');
            }
            // verify required parameter 'end_time' is not null or undefined
            if (end_time === null || end_time === undefined) {
                throw new RequiredError('end_time','Required parameter end_time was null or undefined when calling diagnoseReportsPost.');
            }
            const localVarPath = `/diagnose/reports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (start_time !== undefined) {
                localVarQueryParameter['start_time'] = start_time;
            }

            if (end_time !== undefined) {
                localVarQueryParameter['end_time'] = end_time;
            }

            if (c_start_time !== undefined) {
                localVarQueryParameter['c_start_time'] = c_start_time;
            }

            if (c_end_time !== undefined) {
                localVarQueryParameter['c_end_time'] = c_end_time;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup(token: string, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling downloadProfilingGroup.');
            }
            const localVarPath = `/profiling/group/download`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle(token: string, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling downloadProfilingSingle.');
            }
            const localVarPath = `/profiling/single/download`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hello world!
         * @summary Greet
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooBarNameGet(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling fooBarNameGet.');
            }
            const localVarPath = `/foo/bar/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the dashboard service.
         * @summary Dashboard info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options: any = {}): RequestArgs {
            const localVarPath = `/info/info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail(groupId: string, options: any = {}): RequestArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getProfilingGroupDetail.');
            }
            const localVarPath = `/profiling/group/detail/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download token with a given group ID
         * @summary Get download token for group download
         * @param {string} [id] group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDownloadToken(id?: string, options: any = {}): RequestArgs {
            const localVarPath = `/profiling/group/download/acquire_token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups(options: any = {}): RequestArgs {
            const localVarPath = `/profiling/group/list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download token with a given task ID
         * @summary Get download token for single download
         * @param {string} [id] task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingSingleDownloadToken(id?: string, options: any = {}): RequestArgs {
            const localVarPath = `/profiling/single/download/acquire_token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all databases.
         * @summary Example: Get all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoDatabasesGet(options: any = {}): RequestArgs {
            const localVarPath = `/info/databases`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current login session
         * @summary Current login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoamiGet(options: any = {}): RequestArgs {
            const localVarPath = `/info/whoami`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options: any = {}): RequestArgs {
            const localVarPath = `/keyvisual/heatmaps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startkey !== undefined) {
                localVarQueryParameter['startkey'] = startkey;
            }

            if (endkey !== undefined) {
                localVarQueryParameter['endkey'] = endkey;
            }

            if (starttime !== undefined) {
                localVarQueryParameter['starttime'] = starttime;
            }

            if (endtime !== undefined) {
                localVarQueryParameter['endtime'] = endtime;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get download token with multiple task IDs
         * @summary Get download token
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet(id?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/logs/download/acquire_token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download logs by multiple task IDs
         * @summary Download
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet(token: string, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling logsDownloadGet.');
            }
            const localVarPath = `/logs/download`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and run task group
         * @summary Create and run task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options: any = {}): RequestArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling logsTaskgroupPut.');
            }
            const localVarPath = `/logs/taskgroup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list all log search taskgroups
         * @summary List all task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet(options: any = {}): RequestArgs {
            const localVarPath = `/logs/taskgroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * cancel all running tasks in a task group
         * @summary Cancel running tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsTaskgroupsIdCancelPost.');
            }
            const localVarPath = `/logs/taskgroups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a task group by providing task group ID
         * @summary Delete task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsTaskgroupsIdDelete.');
            }
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list all log search tasks in a task group by providing task group ID
         * @summary List tasks in a task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsTaskgroupsIdGet.');
            }
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * preview fetched logs in a task group by providing task group ID
         * @summary Preview logs in a task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsTaskgroupsIdPreviewGet.');
            }
            const localVarPath = `/logs/taskgroups/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retry tasks that has been failed in a task group
         * @summary Retry failed tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsTaskgroupsIdRetryPost.');
            }
            const localVarPath = `/logs/taskgroups/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start auto profiling
         * @summary Start auto profiling
         * @param {ProfilingStartRequest} req auto profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStartPost(req: ProfilingStartRequest, options: any = {}): RequestArgs {
            // verify required parameter 'req' is not null or undefined
            if (req === null || req === undefined) {
                throw new RequiredError('req','Required parameter req was null or undefined when calling profilingAutoStartPost.');
            }
            const localVarPath = `/profiling/auto/start`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof req !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(req !== undefined ? req : {}) : (req || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop auto profiling
         * @summary Stop auto profiling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStopPost(options: any = {}): RequestArgs {
            const localVarPath = `/profiling/auto/stop`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling(req: ProfilingStartRequest, options: any = {}): RequestArgs {
            // verify required parameter 'req' is not null or undefined
            if (req === null || req === undefined) {
                throw new RequiredError('req','Required parameter req was null or undefined when calling startProfiling.');
            }
            const localVarPath = `/profiling/group/start`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof req !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(req !== undefined ? req : {}) : (req || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statement detail
         * @summary Statement detail
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDetailGet(schema: string, begin_time: string, end_time: string, digest: string, options: any = {}): RequestArgs {
            // verify required parameter 'schema' is not null or undefined
            if (schema === null || schema === undefined) {
                throw new RequiredError('schema','Required parameter schema was null or undefined when calling statementsDetailGet.');
            }
            // verify required parameter 'begin_time' is not null or undefined
            if (begin_time === null || begin_time === undefined) {
                throw new RequiredError('begin_time','Required parameter begin_time was null or undefined when calling statementsDetailGet.');
            }
            // verify required parameter 'end_time' is not null or undefined
            if (end_time === null || end_time === undefined) {
                throw new RequiredError('end_time','Required parameter end_time was null or undefined when calling statementsDetailGet.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling statementsDetailGet.');
            }
            const localVarPath = `/statements/detail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (begin_time !== undefined) {
                localVarQueryParameter['begin_time'] = begin_time;
            }

            if (end_time !== undefined) {
                localVarQueryParameter['end_time'] = end_time;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statement in each node
         * @summary Statement nodes
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsNodesGet(schema: string, begin_time: string, end_time: string, digest: string, options: any = {}): RequestArgs {
            // verify required parameter 'schema' is not null or undefined
            if (schema === null || schema === undefined) {
                throw new RequiredError('schema','Required parameter schema was null or undefined when calling statementsNodesGet.');
            }
            // verify required parameter 'begin_time' is not null or undefined
            if (begin_time === null || begin_time === undefined) {
                throw new RequiredError('begin_time','Required parameter begin_time was null or undefined when calling statementsNodesGet.');
            }
            // verify required parameter 'end_time' is not null or undefined
            if (end_time === null || end_time === undefined) {
                throw new RequiredError('end_time','Required parameter end_time was null or undefined when calling statementsNodesGet.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling statementsNodesGet.');
            }
            const localVarPath = `/statements/nodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (begin_time !== undefined) {
                localVarQueryParameter['begin_time'] = begin_time;
            }

            if (end_time !== undefined) {
                localVarQueryParameter['end_time'] = end_time;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statements overview
         * @summary Statements overview
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} [schemas] Target schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsOverviewsGet(begin_time: string, end_time: string, schemas?: string, options: any = {}): RequestArgs {
            // verify required parameter 'begin_time' is not null or undefined
            if (begin_time === null || begin_time === undefined) {
                throw new RequiredError('begin_time','Required parameter begin_time was null or undefined when calling statementsOverviewsGet.');
            }
            // verify required parameter 'end_time' is not null or undefined
            if (end_time === null || end_time === undefined) {
                throw new RequiredError('end_time','Required parameter end_time was null or undefined when calling statementsOverviewsGet.');
            }
            const localVarPath = `/statements/overviews`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (schemas !== undefined) {
                localVarQueryParameter['schemas'] = schemas;
            }

            if (begin_time !== undefined) {
                localVarQueryParameter['begin_time'] = begin_time;
            }

            if (end_time !== undefined) {
                localVarQueryParameter['end_time'] = end_time;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all databases of TiDB
         * @summary TiDB databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsSchemasGet(options: any = {}): RequestArgs {
            const localVarPath = `/statements/schemas`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all time ranges of the statements
         * @summary Statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsTimeRangesGet(options: any = {}): RequestArgs {
            const localVarPath = `/statements/time_ranges`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete etcd\'s TiDB key with ip:port.
         * @summary Delete etcd\'s tidb key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAddressDelete(options: any = {}): RequestArgs {
            const localVarPath = `/topology/address`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alert number of the alert manager.
         * @summary Get the count of alert
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAlertmanagerAddressCountGet(address: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling topologyAlertmanagerAddressCountGet.');
            }
            const localVarPath = `/topology/alertmanager/{address}/count`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the dashboard topology.
         * @summary Get all Dashboard topology and liveness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAllGet(options: any = {}): RequestArgs {
            const localVarPath = `/topology/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log into dashboard.
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost(message: UserAuthenticateForm, options: any = {}): RequestArgs {
            // verify required parameter 'message' is not null or undefined
            if (message === null || message === undefined) {
                throw new RequiredError('message','Required parameter message was null or undefined when calling userLoginPost.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof message !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(message !== undefined ? message : {}) : (message || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup(groupId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).cancelProfilingGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup(groupId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).deleteProfilingGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdGet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).diagnoseReportsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseReport> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).diagnoseReportsIdStatusGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} start_time start time of the report
         * @param {string} end_time end time of the report
         * @param {string} [c_start_time] compared start time of the report
         * @param {string} [c_end_time] compared end time of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost(start_time: string, end_time: string, c_start_time?: string, c_end_time?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseReportRes> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).diagnoseReportsPost(start_time, end_time, c_start_time, c_end_time, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup(token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).downloadProfilingGroup(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle(token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).downloadProfilingSingle(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Hello world!
         * @summary Greet
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooBarNameGet(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).fooBarNameGet(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about the dashboard service.
         * @summary Dashboard info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoInfoResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail(groupId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingGroupDetailResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getProfilingGroupDetail(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get download token with a given group ID
         * @summary Get download token for group download
         * @param {string} [id] group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDownloadToken(id?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getProfilingGroupDownloadToken(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfilingTaskGroupModel>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getProfilingGroups(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get download token with a given task ID
         * @summary Get download token for single download
         * @param {string} [id] task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingSingleDownloadToken(id?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getProfilingSingleDownloadToken(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all databases.
         * @summary Example: Get all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoDatabasesGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).infoDatabasesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current login session
         * @summary Current login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoamiGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoWhoAmIResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).infoWhoamiGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatrixMatrix> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get download token with multiple task IDs
         * @summary Get download token
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet(id?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsDownloadAcquireTokenGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * download logs by multiple task IDs
         * @summary Download
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet(token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsDownloadGet(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create and run task group
         * @summary Create and run task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupPut(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * list all log search taskgroups
         * @summary List all task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchTaskGroupResponse>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * cancel all running tasks in a task group
         * @summary Cancel running tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsIdCancelPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * delete a task group by providing task group ID
         * @summary Delete task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * list all log search tasks in a task group by providing task group ID
         * @summary List tasks in a task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * preview fetched logs in a task group by providing task group ID
         * @summary Preview logs in a task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchPreviewModel>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsIdPreviewGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * retry tasks that has been failed in a task group
         * @summary Retry failed tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).logsTaskgroupsIdRetryPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start auto profiling
         * @summary Start auto profiling
         * @param {ProfilingStartRequest} req auto profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStartPost(req: ProfilingStartRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).profilingAutoStartPost(req, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stop auto profiling
         * @summary Stop auto profiling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStopPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).profilingAutoStopPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling(req: ProfilingStartRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingTaskGroupModel> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).startProfiling(req, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get statement detail
         * @summary Statement detail
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDetailGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementDetail> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).statementsDetailGet(schema, begin_time, end_time, digest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get statement in each node
         * @summary Statement nodes
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsNodesGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementNode>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).statementsNodesGet(schema, begin_time, end_time, digest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get statements overview
         * @summary Statements overview
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} [schemas] Target schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsOverviewsGet(begin_time: string, end_time: string, schemas?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementOverview>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).statementsOverviewsGet(begin_time, end_time, schemas, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all databases of TiDB
         * @summary TiDB databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsSchemasGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).statementsSchemasGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all time ranges of the statements
         * @summary Statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsTimeRangesGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementTimeRange>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).statementsTimeRangesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete etcd\'s TiDB key with ip:port.
         * @summary Delete etcd\'s tidb key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAddressDelete(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).topologyAddressDelete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get alert number of the alert manager.
         * @summary Get the count of alert
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAlertmanagerAddressCountGet(address: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).topologyAlertmanagerAddressCountGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about the dashboard topology.
         * @summary Get all Dashboard topology and liveness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAllGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoClusterInfo> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).topologyAllGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Log into dashboard.
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost(message: UserAuthenticateForm, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTokenResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).userLoginPost(message, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup(groupId: string, options?: any) {
            return DefaultApiFp(configuration).cancelProfilingGroup(groupId, options)(axios, basePath);
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup(groupId: string, options?: any) {
            return DefaultApiFp(configuration).deleteProfilingGroup(groupId, options)(axios, basePath);
        },
        /**
         * Get sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdGet(id: string, options?: any) {
            return DefaultApiFp(configuration).diagnoseReportsIdGet(id, options)(axios, basePath);
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet(id: string, options?: any) {
            return DefaultApiFp(configuration).diagnoseReportsIdStatusGet(id, options)(axios, basePath);
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {string} start_time start time of the report
         * @param {string} end_time end time of the report
         * @param {string} [c_start_time] compared start time of the report
         * @param {string} [c_end_time] compared end time of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost(start_time: string, end_time: string, c_start_time?: string, c_end_time?: string, options?: any) {
            return DefaultApiFp(configuration).diagnoseReportsPost(start_time, end_time, c_start_time, c_end_time, options)(axios, basePath);
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup(token: string, options?: any) {
            return DefaultApiFp(configuration).downloadProfilingGroup(token, options)(axios, basePath);
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle(token: string, options?: any) {
            return DefaultApiFp(configuration).downloadProfilingSingle(token, options)(axios, basePath);
        },
        /**
         * Hello world!
         * @summary Greet
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooBarNameGet(name: string, options?: any) {
            return DefaultApiFp(configuration).fooBarNameGet(name, options)(axios, basePath);
        },
        /**
         * Get information about the dashboard service.
         * @summary Dashboard info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any) {
            return DefaultApiFp(configuration).getInfo(options)(axios, basePath);
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail(groupId: string, options?: any) {
            return DefaultApiFp(configuration).getProfilingGroupDetail(groupId, options)(axios, basePath);
        },
        /**
         * Get download token with a given group ID
         * @summary Get download token for group download
         * @param {string} [id] group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDownloadToken(id?: string, options?: any) {
            return DefaultApiFp(configuration).getProfilingGroupDownloadToken(id, options)(axios, basePath);
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups(options?: any) {
            return DefaultApiFp(configuration).getProfilingGroups(options)(axios, basePath);
        },
        /**
         * Get download token with a given task ID
         * @summary Get download token for single download
         * @param {string} [id] task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingSingleDownloadToken(id?: string, options?: any) {
            return DefaultApiFp(configuration).getProfilingSingleDownloadToken(id, options)(axios, basePath);
        },
        /**
         * Get all databases.
         * @summary Example: Get all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoDatabasesGet(options?: any) {
            return DefaultApiFp(configuration).infoDatabasesGet(options)(axios, basePath);
        },
        /**
         * Get current login session
         * @summary Current login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoamiGet(options?: any) {
            return DefaultApiFp(configuration).infoWhoamiGet(options)(axios, basePath);
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: any) {
            return DefaultApiFp(configuration).keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options)(axios, basePath);
        },
        /**
         * get download token with multiple task IDs
         * @summary Get download token
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet(id?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).logsDownloadAcquireTokenGet(id, options)(axios, basePath);
        },
        /**
         * download logs by multiple task IDs
         * @summary Download
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet(token: string, options?: any) {
            return DefaultApiFp(configuration).logsDownloadGet(token, options)(axios, basePath);
        },
        /**
         * Create and run task group
         * @summary Create and run task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupPut(request, options)(axios, basePath);
        },
        /**
         * list all log search taskgroups
         * @summary List all task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet(options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsGet(options)(axios, basePath);
        },
        /**
         * cancel all running tasks in a task group
         * @summary Cancel running tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost(id: string, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsIdCancelPost(id, options)(axios, basePath);
        },
        /**
         * delete a task group by providing task group ID
         * @summary Delete task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete(id: string, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsIdDelete(id, options)(axios, basePath);
        },
        /**
         * list all log search tasks in a task group by providing task group ID
         * @summary List tasks in a task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet(id: string, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsIdGet(id, options)(axios, basePath);
        },
        /**
         * preview fetched logs in a task group by providing task group ID
         * @summary Preview logs in a task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet(id: string, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsIdPreviewGet(id, options)(axios, basePath);
        },
        /**
         * retry tasks that has been failed in a task group
         * @summary Retry failed tasks
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost(id: string, options?: any) {
            return DefaultApiFp(configuration).logsTaskgroupsIdRetryPost(id, options)(axios, basePath);
        },
        /**
         * Start auto profiling
         * @summary Start auto profiling
         * @param {ProfilingStartRequest} req auto profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStartPost(req: ProfilingStartRequest, options?: any) {
            return DefaultApiFp(configuration).profilingAutoStartPost(req, options)(axios, basePath);
        },
        /**
         * Stop auto profiling
         * @summary Stop auto profiling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingAutoStopPost(options?: any) {
            return DefaultApiFp(configuration).profilingAutoStopPost(options)(axios, basePath);
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling(req: ProfilingStartRequest, options?: any) {
            return DefaultApiFp(configuration).startProfiling(req, options)(axios, basePath);
        },
        /**
         * Get statement detail
         * @summary Statement detail
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDetailGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any) {
            return DefaultApiFp(configuration).statementsDetailGet(schema, begin_time, end_time, digest, options)(axios, basePath);
        },
        /**
         * Get statement in each node
         * @summary Statement nodes
         * @param {string} schema Statement schema
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} digest Statement digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsNodesGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any) {
            return DefaultApiFp(configuration).statementsNodesGet(schema, begin_time, end_time, digest, options)(axios, basePath);
        },
        /**
         * Get statements overview
         * @summary Statements overview
         * @param {string} begin_time Statement begin time
         * @param {string} end_time Statement end time
         * @param {string} [schemas] Target schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsOverviewsGet(begin_time: string, end_time: string, schemas?: string, options?: any) {
            return DefaultApiFp(configuration).statementsOverviewsGet(begin_time, end_time, schemas, options)(axios, basePath);
        },
        /**
         * Get all databases of TiDB
         * @summary TiDB databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsSchemasGet(options?: any) {
            return DefaultApiFp(configuration).statementsSchemasGet(options)(axios, basePath);
        },
        /**
         * Get all time ranges of the statements
         * @summary Statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsTimeRangesGet(options?: any) {
            return DefaultApiFp(configuration).statementsTimeRangesGet(options)(axios, basePath);
        },
        /**
         * Delete etcd\'s TiDB key with ip:port.
         * @summary Delete etcd\'s tidb key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAddressDelete(options?: any) {
            return DefaultApiFp(configuration).topologyAddressDelete(options)(axios, basePath);
        },
        /**
         * Get alert number of the alert manager.
         * @summary Get the count of alert
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAlertmanagerAddressCountGet(address: string, options?: any) {
            return DefaultApiFp(configuration).topologyAlertmanagerAddressCountGet(address, options)(axios, basePath);
        },
        /**
         * Get information about the dashboard topology.
         * @summary Get all Dashboard topology and liveness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyAllGet(options?: any) {
            return DefaultApiFp(configuration).topologyAllGet(options)(axios, basePath);
        },
        /**
         * Log into dashboard.
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost(message: UserAuthenticateForm, options?: any) {
            return DefaultApiFp(configuration).userLoginPost(message, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelProfilingGroup(groupId: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelProfilingGroup(groupId, options)(this.axios, this.basePath);
    }

    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteProfilingGroup(groupId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteProfilingGroup(groupId, options)(this.axios, this.basePath);
    }

    /**
     * Get sql diagnosis report
     * @summary SQL diagnosis report
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdGet(id, options)(this.axios, this.basePath);
    }

    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdStatusGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdStatusGet(id, options)(this.axios, this.basePath);
    }

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {string} start_time start time of the report
     * @param {string} end_time end time of the report
     * @param {string} [c_start_time] compared start time of the report
     * @param {string} [c_end_time] compared end time of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsPost(start_time: string, end_time: string, c_start_time?: string, c_end_time?: string, options?: any) {
        return DefaultApiFp(this.configuration).diagnoseReportsPost(start_time, end_time, c_start_time, c_end_time, options)(this.axios, this.basePath);
    }

    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingGroup(token: string, options?: any) {
        return DefaultApiFp(this.configuration).downloadProfilingGroup(token, options)(this.axios, this.basePath);
    }

    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingSingle(token: string, options?: any) {
        return DefaultApiFp(this.configuration).downloadProfilingSingle(token, options)(this.axios, this.basePath);
    }

    /**
     * Hello world!
     * @summary Greet
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fooBarNameGet(name: string, options?: any) {
        return DefaultApiFp(this.configuration).fooBarNameGet(name, options)(this.axios, this.basePath);
    }

    /**
     * Get information about the dashboard service.
     * @summary Dashboard info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInfo(options?: any) {
        return DefaultApiFp(this.configuration).getInfo(options)(this.axios, this.basePath);
    }

    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroupDetail(groupId: string, options?: any) {
        return DefaultApiFp(this.configuration).getProfilingGroupDetail(groupId, options)(this.axios, this.basePath);
    }

    /**
     * Get download token with a given group ID
     * @summary Get download token for group download
     * @param {string} [id] group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroupDownloadToken(id?: string, options?: any) {
        return DefaultApiFp(this.configuration).getProfilingGroupDownloadToken(id, options)(this.axios, this.basePath);
    }

    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroups(options?: any) {
        return DefaultApiFp(this.configuration).getProfilingGroups(options)(this.axios, this.basePath);
    }

    /**
     * Get download token with a given task ID
     * @summary Get download token for single download
     * @param {string} [id] task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingSingleDownloadToken(id?: string, options?: any) {
        return DefaultApiFp(this.configuration).getProfilingSingleDownloadToken(id, options)(this.axios, this.basePath);
    }

    /**
     * Get all databases.
     * @summary Example: Get all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoDatabasesGet(options?: any) {
        return DefaultApiFp(this.configuration).infoDatabasesGet(options)(this.axios, this.basePath);
    }

    /**
     * Get current login session
     * @summary Current login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoWhoamiGet(options?: any) {
        return DefaultApiFp(this.configuration).infoWhoamiGet(options)(this.axios, this.basePath);
    }

    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {string} [startkey] The start of the key range
     * @param {string} [endkey] The end of the key range
     * @param {number} [starttime] The start of the time range (Unix)
     * @param {number} [endtime] The end of the time range (Unix)
     * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: any) {
        return DefaultApiFp(this.configuration).keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options)(this.axios, this.basePath);
    }

    /**
     * get download token with multiple task IDs
     * @summary Get download token
     * @param {Array<string>} [id] task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadAcquireTokenGet(id?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).logsDownloadAcquireTokenGet(id, options)(this.axios, this.basePath);
    }

    /**
     * download logs by multiple task IDs
     * @summary Download
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadGet(token: string, options?: any) {
        return DefaultApiFp(this.configuration).logsDownloadGet(token, options)(this.axios, this.basePath);
    }

    /**
     * Create and run task group
     * @summary Create and run task group
     * @param {LogsearchCreateTaskGroupRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupPut(request, options)(this.axios, this.basePath);
    }

    /**
     * list all log search taskgroups
     * @summary List all task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsGet(options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsGet(options)(this.axios, this.basePath);
    }

    /**
     * cancel all running tasks in a task group
     * @summary Cancel running tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdCancelPost(id: string, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdCancelPost(id, options)(this.axios, this.basePath);
    }

    /**
     * delete a task group by providing task group ID
     * @summary Delete task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdDelete(id: string, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdDelete(id, options)(this.axios, this.basePath);
    }

    /**
     * list all log search tasks in a task group by providing task group ID
     * @summary List tasks in a task group
     * @param {string} id Task Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdGet(id, options)(this.axios, this.basePath);
    }

    /**
     * preview fetched logs in a task group by providing task group ID
     * @summary Preview logs in a task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdPreviewGet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdPreviewGet(id, options)(this.axios, this.basePath);
    }

    /**
     * retry tasks that has been failed in a task group
     * @summary Retry failed tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdRetryPost(id: string, options?: any) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdRetryPost(id, options)(this.axios, this.basePath);
    }

    /**
     * Start auto profiling
     * @summary Start auto profiling
     * @param {ProfilingStartRequest} req auto profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingAutoStartPost(req: ProfilingStartRequest, options?: any) {
        return DefaultApiFp(this.configuration).profilingAutoStartPost(req, options)(this.axios, this.basePath);
    }

    /**
     * Stop auto profiling
     * @summary Stop auto profiling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingAutoStopPost(options?: any) {
        return DefaultApiFp(this.configuration).profilingAutoStopPost(options)(this.axios, this.basePath);
    }

    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {ProfilingStartRequest} req profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startProfiling(req: ProfilingStartRequest, options?: any) {
        return DefaultApiFp(this.configuration).startProfiling(req, options)(this.axios, this.basePath);
    }

    /**
     * Get statement detail
     * @summary Statement detail
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsDetailGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any) {
        return DefaultApiFp(this.configuration).statementsDetailGet(schema, begin_time, end_time, digest, options)(this.axios, this.basePath);
    }

    /**
     * Get statement in each node
     * @summary Statement nodes
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsNodesGet(schema: string, begin_time: string, end_time: string, digest: string, options?: any) {
        return DefaultApiFp(this.configuration).statementsNodesGet(schema, begin_time, end_time, digest, options)(this.axios, this.basePath);
    }

    /**
     * Get statements overview
     * @summary Statements overview
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} [schemas] Target schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsOverviewsGet(begin_time: string, end_time: string, schemas?: string, options?: any) {
        return DefaultApiFp(this.configuration).statementsOverviewsGet(begin_time, end_time, schemas, options)(this.axios, this.basePath);
    }

    /**
     * Get all databases of TiDB
     * @summary TiDB databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsSchemasGet(options?: any) {
        return DefaultApiFp(this.configuration).statementsSchemasGet(options)(this.axios, this.basePath);
    }

    /**
     * Get all time ranges of the statements
     * @summary Statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsTimeRangesGet(options?: any) {
        return DefaultApiFp(this.configuration).statementsTimeRangesGet(options)(this.axios, this.basePath);
    }

    /**
     * Delete etcd\'s TiDB key with ip:port.
     * @summary Delete etcd\'s tidb key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topologyAddressDelete(options?: any) {
        return DefaultApiFp(this.configuration).topologyAddressDelete(options)(this.axios, this.basePath);
    }

    /**
     * Get alert number of the alert manager.
     * @summary Get the count of alert
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topologyAlertmanagerAddressCountGet(address: string, options?: any) {
        return DefaultApiFp(this.configuration).topologyAlertmanagerAddressCountGet(address, options)(this.axios, this.basePath);
    }

    /**
     * Get information about the dashboard topology.
     * @summary Get all Dashboard topology and liveness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topologyAllGet(options?: any) {
        return DefaultApiFp(this.configuration).topologyAllGet(options)(this.axios, this.basePath);
    }

    /**
     * Log into dashboard.
     * @summary Log in
     * @param {UserAuthenticateForm} message Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userLoginPost(message: UserAuthenticateForm, options?: any) {
        return DefaultApiFp(this.configuration).userLoginPost(message, options)(this.axios, this.basePath);
    }

}


