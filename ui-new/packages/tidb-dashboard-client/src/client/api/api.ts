/* tslint:disable */
/* eslint-disable */
/**
 * Dashboard API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ClusterinfoClusterStatistics
 */
export interface ClusterinfoClusterStatistics {
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatistics
     */
    'probe_failure_hosts'?: number;
    /**
     * 
     * @type {{ [key: string]: ClusterinfoClusterStatisticsPartial; }}
     * @memberof ClusterinfoClusterStatistics
     */
    'stats_by_instance_kind'?: { [key: string]: ClusterinfoClusterStatisticsPartial; };
    /**
     * 
     * @type {ClusterinfoClusterStatisticsPartial}
     * @memberof ClusterinfoClusterStatistics
     */
    'total_stats'?: ClusterinfoClusterStatisticsPartial;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterinfoClusterStatistics
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterinfoClusterStatisticsPartial
 */
export interface ClusterinfoClusterStatisticsPartial {
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatisticsPartial
     */
    'number_of_hosts'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatisticsPartial
     */
    'number_of_instances'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatisticsPartial
     */
    'total_logical_cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatisticsPartial
     */
    'total_memory_capacity_bytes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterinfoClusterStatisticsPartial
     */
    'total_physical_cores'?: number;
}
/**
 * 
 * @export
 * @interface ClusterinfoGetHostsInfoResponse
 */
export interface ClusterinfoGetHostsInfoResponse {
    /**
     * 
     * @type {Array<HostinfoInfo>}
     * @memberof ClusterinfoGetHostsInfoResponse
     */
    'hosts'?: Array<HostinfoInfo>;
    /**
     * 
     * @type {RestErrorResponse}
     * @memberof ClusterinfoGetHostsInfoResponse
     */
    'warning'?: RestErrorResponse;
}
/**
 * 
 * @export
 * @interface ClusterinfoStoreTopologyResponse
 */
export interface ClusterinfoStoreTopologyResponse {
    /**
     * 
     * @type {Array<TopologyStoreInfo>}
     * @memberof ClusterinfoStoreTopologyResponse
     */
    'tiflash'?: Array<TopologyStoreInfo>;
    /**
     * 
     * @type {Array<TopologyStoreInfo>}
     * @memberof ClusterinfoStoreTopologyResponse
     */
    'tikv'?: Array<TopologyStoreInfo>;
}
/**
 * 
 * @export
 * @interface CodeShareRequest
 */
export interface CodeShareRequest {
    /**
     * 
     * @type {number}
     * @memberof CodeShareRequest
     */
    'expire_in_sec'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CodeShareRequest
     */
    'revoke_write_priv'?: boolean;
}
/**
 * 
 * @export
 * @interface CodeShareResponse
 */
export interface CodeShareResponse {
    /**
     * 
     * @type {string}
     * @memberof CodeShareResponse
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface ConfigKeyVisualConfig
 */
export interface ConfigKeyVisualConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigKeyVisualConfig
     */
    'auto_collection_disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigKeyVisualConfig
     */
    'policy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigKeyVisualConfig
     */
    'policy_kv_separator'?: string;
}
/**
 * 
 * @export
 * @interface ConfigProfilingConfig
 */
export interface ConfigProfilingConfig {
    /**
     * 
     * @type {number}
     * @memberof ConfigProfilingConfig
     */
    'auto_collection_duration_secs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigProfilingConfig
     */
    'auto_collection_interval_secs'?: number;
    /**
     * 
     * @type {Array<ModelRequestTargetNode>}
     * @memberof ConfigProfilingConfig
     */
    'auto_collection_targets'?: Array<ModelRequestTargetNode>;
}
/**
 * 
 * @export
 * @interface ConfigSSOCoreConfig
 */
export interface ConfigSSOCoreConfig {
    /**
     * 
     * @type {string}
     * @memberof ConfigSSOCoreConfig
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigSSOCoreConfig
     */
    'discovery_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigSSOCoreConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigSSOCoreConfig
     */
    'is_read_only'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfigurationAllConfigItems
 */
export interface ConfigurationAllConfigItems {
    /**
     * 
     * @type {Array<RestErrorResponse>}
     * @memberof ConfigurationAllConfigItems
     */
    'errors'?: Array<RestErrorResponse>;
    /**
     * 
     * @type {{ [key: string]: Array<ConfigurationItem>; }}
     * @memberof ConfigurationAllConfigItems
     */
    'items'?: { [key: string]: Array<ConfigurationItem>; };
}
/**
 * 
 * @export
 * @interface ConfigurationEditRequest
 */
export interface ConfigurationEditRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationEditRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationEditRequest
     */
    'kind'?: string;
    /**
     * 
     * @type {object}
     * @memberof ConfigurationEditRequest
     */
    'new_value'?: object;
}
/**
 * 
 * @export
 * @interface ConfigurationEditResponse
 */
export interface ConfigurationEditResponse {
    /**
     * 
     * @type {Array<RestErrorResponse>}
     * @memberof ConfigurationEditResponse
     */
    'warnings'?: Array<RestErrorResponse>;
}
/**
 * 
 * @export
 * @interface ConfigurationItem
 */
export interface ConfigurationItem {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItem
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationItem
     */
    'is_editable'?: boolean;
    /**
     * TODO: Support per-instance config
     * @type {boolean}
     * @memberof ConfigurationItem
     */
    'is_multi_value'?: boolean;
    /**
     * When multi value present, this contains one of the value
     * @type {object}
     * @memberof ConfigurationItem
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface ConprofComponent
 */
export interface ConprofComponent {
    /**
     * 
     * @type {string}
     * @memberof ConprofComponent
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConprofComponent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConprofComponent
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofComponent
     */
    'status_port'?: number;
}
/**
 * 
 * @export
 * @interface ConprofComponentNum
 */
export interface ConprofComponentNum {
    /**
     * 
     * @type {number}
     * @memberof ConprofComponentNum
     */
    'pd'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofComponentNum
     */
    'tidb'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofComponentNum
     */
    'tiflash'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofComponentNum
     */
    'tikv'?: number;
}
/**
 * 
 * @export
 * @interface ConprofContinuousProfilingConfig
 */
export interface ConprofContinuousProfilingConfig {
    /**
     * 
     * @type {number}
     * @memberof ConprofContinuousProfilingConfig
     */
    'data_retention_seconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConprofContinuousProfilingConfig
     */
    'enable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConprofContinuousProfilingConfig
     */
    'interval_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofContinuousProfilingConfig
     */
    'profile_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofContinuousProfilingConfig
     */
    'timeout_seconds'?: number;
}
/**
 * 
 * @export
 * @interface ConprofEstimateSizeRes
 */
export interface ConprofEstimateSizeRes {
    /**
     * 
     * @type {number}
     * @memberof ConprofEstimateSizeRes
     */
    'instance_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConprofEstimateSizeRes
     */
    'profile_size'?: number;
}
/**
 * 
 * @export
 * @interface ConprofGroupProfileDetail
 */
export interface ConprofGroupProfileDetail {
    /**
     * 
     * @type {number}
     * @memberof ConprofGroupProfileDetail
     */
    'profile_duration_secs'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConprofGroupProfileDetail
     */
    'state'?: string;
    /**
     * 
     * @type {Array<ConprofProfileDetail>}
     * @memberof ConprofGroupProfileDetail
     */
    'target_profiles'?: Array<ConprofProfileDetail>;
    /**
     * 
     * @type {number}
     * @memberof ConprofGroupProfileDetail
     */
    'ts'?: number;
}
/**
 * 
 * @export
 * @interface ConprofGroupProfiles
 */
export interface ConprofGroupProfiles {
    /**
     * 
     * @type {ConprofComponentNum}
     * @memberof ConprofGroupProfiles
     */
    'component_num'?: ConprofComponentNum;
    /**
     * 
     * @type {number}
     * @memberof ConprofGroupProfiles
     */
    'profile_duration_secs'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConprofGroupProfiles
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConprofGroupProfiles
     */
    'ts'?: number;
}
/**
 * 
 * @export
 * @interface ConprofNgMonitoringConfig
 */
export interface ConprofNgMonitoringConfig {
    /**
     * 
     * @type {ConprofContinuousProfilingConfig}
     * @memberof ConprofNgMonitoringConfig
     */
    'continuous_profiling'?: ConprofContinuousProfilingConfig;
}
/**
 * 
 * @export
 * @interface ConprofProfileDetail
 */
export interface ConprofProfileDetail {
    /**
     * 
     * @type {string}
     * @memberof ConprofProfileDetail
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConprofProfileDetail
     */
    'profile_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConprofProfileDetail
     */
    'state'?: string;
    /**
     * 
     * @type {ConprofTarget}
     * @memberof ConprofProfileDetail
     */
    'target'?: ConprofTarget;
}
/**
 * 
 * @export
 * @interface ConprofTarget
 */
export interface ConprofTarget {
    /**
     * 
     * @type {string}
     * @memberof ConprofTarget
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConprofTarget
     */
    'component'?: string;
}
/**
 * 
 * @export
 * @interface DecoratorLabelKey
 */
export interface DecoratorLabelKey {
    /**
     * 
     * @type {string}
     * @memberof DecoratorLabelKey
     */
    'key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DecoratorLabelKey
     */
    'labels': Array<string>;
}
/**
 * 
 * @export
 * @interface DiagnoseGenDiagnosisReportRequest
 */
export interface DiagnoseGenDiagnosisReportRequest {
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenDiagnosisReportRequest
     */
    'end_time'?: number;
    /**
     * values: config, error, performance
     * @type {string}
     * @memberof DiagnoseGenDiagnosisReportRequest
     */
    'kind'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenDiagnosisReportRequest
     */
    'start_time'?: number;
}
/**
 * 
 * @export
 * @interface DiagnoseGenerateMetricsRelationRequest
 */
export interface DiagnoseGenerateMetricsRelationRequest {
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateMetricsRelationRequest
     */
    'end_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateMetricsRelationRequest
     */
    'start_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseGenerateMetricsRelationRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DiagnoseGenerateReportRequest
 */
export interface DiagnoseGenerateReportRequest {
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateReportRequest
     */
    'compare_end_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateReportRequest
     */
    'compare_start_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateReportRequest
     */
    'end_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiagnoseGenerateReportRequest
     */
    'start_time'?: number;
}
/**
 * 
 * @export
 * @interface DiagnoseReport
 */
export interface DiagnoseReport {
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'compare_end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'compare_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'id'?: string;
    /**
     * 0~100
     * @type {number}
     * @memberof DiagnoseReport
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseReport
     */
    'start_time'?: string;
}
/**
 * 
 * @export
 * @interface DiagnoseTableDef
 */
export interface DiagnoseTableDef {
    /**
     * The category of the table, such as [TiDB]
     * @type {Array<string>}
     * @memberof DiagnoseTableDef
     */
    'category'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DiagnoseTableDef
     */
    'column'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseTableDef
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<DiagnoseTableRowDef>}
     * @memberof DiagnoseTableDef
     */
    'rows'?: Array<DiagnoseTableRowDef>;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseTableDef
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface DiagnoseTableRowDef
 */
export interface DiagnoseTableRowDef {
    /**
     * 
     * @type {string}
     * @memberof DiagnoseTableRowDef
     */
    'comment'?: string;
    /**
     * SubValues need fold default.
     * @type {Array<Array<string>>}
     * @memberof DiagnoseTableRowDef
     */
    'sub_values'?: Array<Array<string>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DiagnoseTableRowDef
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EndpointAPIDefinition
 */
export interface EndpointAPIDefinition {
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIDefinition
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIDefinition
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIDefinition
     */
    'path'?: string;
    /**
     * e.g. /stats/dump/{db}/{table} -> db, table
     * @type {Array<EndpointAPIParamDefinition>}
     * @memberof EndpointAPIDefinition
     */
    'path_params'?: Array<EndpointAPIParamDefinition>;
    /**
     * e.g. /debug/pprof?seconds=1 -> seconds
     * @type {Array<EndpointAPIParamDefinition>}
     * @memberof EndpointAPIDefinition
     */
    'query_params'?: Array<EndpointAPIParamDefinition>;
}
/**
 * 
 * @export
 * @interface EndpointAPIParamDefinition
 */
export interface EndpointAPIParamDefinition {
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIParamDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EndpointAPIParamDefinition
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EndpointAPIParamDefinition
     */
    'ui_kind'?: string;
    /**
     * varies by different ui kinds
     * @type {object}
     * @memberof EndpointAPIParamDefinition
     */
    'ui_props'?: object;
}
/**
 * 
 * @export
 * @interface EndpointRequestPayload
 */
export interface EndpointRequestPayload {
    /**
     * 
     * @type {string}
     * @memberof EndpointRequestPayload
     */
    'api_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointRequestPayload
     */
    'host'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EndpointRequestPayload
     */
    'param_values'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof EndpointRequestPayload
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface HostinfoCPUInfo
 */
export interface HostinfoCPUInfo {
    /**
     * 
     * @type {string}
     * @memberof HostinfoCPUInfo
     */
    'arch'?: string;
    /**
     * 
     * @type {number}
     * @memberof HostinfoCPUInfo
     */
    'logical_cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof HostinfoCPUInfo
     */
    'physical_cores'?: number;
}
/**
 * 
 * @export
 * @interface HostinfoCPUUsageInfo
 */
export interface HostinfoCPUUsageInfo {
    /**
     * 
     * @type {number}
     * @memberof HostinfoCPUUsageInfo
     */
    'idle'?: number;
    /**
     * 
     * @type {number}
     * @memberof HostinfoCPUUsageInfo
     */
    'system'?: number;
}
/**
 * 
 * @export
 * @interface HostinfoInfo
 */
export interface HostinfoInfo {
    /**
     * 
     * @type {HostinfoCPUInfo}
     * @memberof HostinfoInfo
     */
    'cpu_info'?: HostinfoCPUInfo;
    /**
     * 
     * @type {HostinfoCPUUsageInfo}
     * @memberof HostinfoInfo
     */
    'cpu_usage'?: HostinfoCPUUsageInfo;
    /**
     * 
     * @type {string}
     * @memberof HostinfoInfo
     */
    'host'?: string;
    /**
     * Instances in the current host. The key is instance address
     * @type {{ [key: string]: HostinfoInstanceInfo; }}
     * @memberof HostinfoInfo
     */
    'instances'?: { [key: string]: HostinfoInstanceInfo; };
    /**
     * 
     * @type {HostinfoMemoryUsageInfo}
     * @memberof HostinfoInfo
     */
    'memory_usage'?: HostinfoMemoryUsageInfo;
    /**
     * Containing unused partitions. The key is path in lower case. Note: deviceName is not used as the key, since TiDB and TiKV may return different deviceName for the same device.
     * @type {{ [key: string]: HostinfoPartitionInfo; }}
     * @memberof HostinfoInfo
     */
    'partitions'?: { [key: string]: HostinfoPartitionInfo; };
}
/**
 * 
 * @export
 * @interface HostinfoInstanceInfo
 */
export interface HostinfoInstanceInfo {
    /**
     * 
     * @type {string}
     * @memberof HostinfoInstanceInfo
     */
    'partition_path_lower'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostinfoInstanceInfo
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface HostinfoMemoryUsageInfo
 */
export interface HostinfoMemoryUsageInfo {
    /**
     * 
     * @type {number}
     * @memberof HostinfoMemoryUsageInfo
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof HostinfoMemoryUsageInfo
     */
    'used'?: number;
}
/**
 * 
 * @export
 * @interface HostinfoPartitionInfo
 */
export interface HostinfoPartitionInfo {
    /**
     * 
     * @type {number}
     * @memberof HostinfoPartitionInfo
     */
    'free'?: number;
    /**
     * 
     * @type {string}
     * @memberof HostinfoPartitionInfo
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostinfoPartitionInfo
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof HostinfoPartitionInfo
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface InfoInfoResponse
 */
export interface InfoInfoResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InfoInfoResponse
     */
    'enable_experimental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InfoInfoResponse
     */
    'enable_telemetry'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InfoInfoResponse
     */
    'ngm_state'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoInfoResponse
     */
    'supported_features'?: Array<string>;
    /**
     * 
     * @type {VersionInfo}
     * @memberof InfoInfoResponse
     */
    'version'?: VersionInfo;
}
/**
 * 
 * @export
 * @interface InfoTableSchema
 */
export interface InfoTableSchema {
    /**
     * 
     * @type {string}
     * @memberof InfoTableSchema
     */
    'table_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTableSchema
     */
    'table_name'?: string;
}
/**
 * 
 * @export
 * @interface InfoWhoAmIResponse
 */
export interface InfoWhoAmIResponse {
    /**
     * 
     * @type {string}
     * @memberof InfoWhoAmIResponse
     */
    'display_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InfoWhoAmIResponse
     */
    'is_shareable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InfoWhoAmIResponse
     */
    'is_writeable'?: boolean;
}
/**
 * 
 * @export
 * @interface LogsearchCreateTaskGroupRequest
 */
export interface LogsearchCreateTaskGroupRequest {
    /**
     * 
     * @type {LogsearchSearchLogRequest}
     * @memberof LogsearchCreateTaskGroupRequest
     */
    'request': LogsearchSearchLogRequest;
    /**
     * 
     * @type {Array<ModelRequestTargetNode>}
     * @memberof LogsearchCreateTaskGroupRequest
     */
    'targets': Array<ModelRequestTargetNode>;
}
/**
 * 
 * @export
 * @interface LogsearchPreviewModel
 */
export interface LogsearchPreviewModel {
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchPreviewModel
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    'task_group_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    'task_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchPreviewModel
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface LogsearchSearchLogRequest
 */
export interface LogsearchSearchLogRequest {
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchLogRequest
     */
    'end_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchLogRequest
     */
    'min_level'?: number;
    /**
     * We use a string array to represent multiple CNF pattern sceniaor like: SELECT * FROM t WHERE c LIKE \'%s%\' and c REGEXP \'.*a.*\' because Golang and Rust don\'t support perl-like (?=re1)(?=re2)
     * @type {Array<string>}
     * @memberof LogsearchSearchLogRequest
     */
    'patterns'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LogsearchSearchLogRequest
     */
    'start_time'?: number;
}
/**
 * 
 * @export
 * @interface LogsearchTaskGroupModel
 */
export interface LogsearchTaskGroupModel {
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskGroupModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskGroupModel
     */
    'log_store_dir'?: string;
    /**
     * 
     * @type {LogsearchSearchLogRequest}
     * @memberof LogsearchTaskGroupModel
     */
    'search_request'?: LogsearchSearchLogRequest;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskGroupModel
     */
    'state'?: number;
    /**
     * 
     * @type {ModelRequestTargetStatistics}
     * @memberof LogsearchTaskGroupModel
     */
    'target_stats'?: ModelRequestTargetStatistics;
}
/**
 * 
 * @export
 * @interface LogsearchTaskGroupResponse
 */
export interface LogsearchTaskGroupResponse {
    /**
     * 
     * @type {LogsearchTaskGroupModel}
     * @memberof LogsearchTaskGroupResponse
     */
    'task_group'?: LogsearchTaskGroupModel;
    /**
     * 
     * @type {Array<LogsearchTaskModel>}
     * @memberof LogsearchTaskGroupResponse
     */
    'tasks'?: Array<LogsearchTaskModel>;
}
/**
 * 
 * @export
 * @interface LogsearchTaskModel
 */
export interface LogsearchTaskModel {
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskModel
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskModel
     */
    'log_store_path'?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof LogsearchTaskModel
     */
    'slow_log_store_path'?: string;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    'state'?: number;
    /**
     * 
     * @type {ModelRequestTargetNode}
     * @memberof LogsearchTaskModel
     */
    'target'?: ModelRequestTargetNode;
    /**
     * 
     * @type {number}
     * @memberof LogsearchTaskModel
     */
    'task_group_id'?: number;
}
/**
 * 
 * @export
 * @interface MatrixMatrix
 */
export interface MatrixMatrix {
    /**
     * 
     * @type {{ [key: string]: Array<Array<number>>; }}
     * @memberof MatrixMatrix
     */
    'data': { [key: string]: Array<Array<number>>; };
    /**
     * 
     * @type {Array<DecoratorLabelKey>}
     * @memberof MatrixMatrix
     */
    'keyAxis': Array<DecoratorLabelKey>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MatrixMatrix
     */
    'timeAxis': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricsGetPromAddressConfigResponse
 */
export interface MetricsGetPromAddressConfigResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricsGetPromAddressConfigResponse
     */
    'customized_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGetPromAddressConfigResponse
     */
    'deployed_addr'?: string;
}
/**
 * 
 * @export
 * @interface MetricsPutCustomPromAddressRequest
 */
export interface MetricsPutCustomPromAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof MetricsPutCustomPromAddressRequest
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface MetricsPutCustomPromAddressResponse
 */
export interface MetricsPutCustomPromAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricsPutCustomPromAddressResponse
     */
    'normalized_address'?: string;
}
/**
 * 
 * @export
 * @interface MetricsQueryResponse
 */
export interface MetricsQueryResponse {
    /**
     * 
     * @type {object}
     * @memberof MetricsQueryResponse
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof MetricsQueryResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ModelRequestTargetNode
 */
export interface ModelRequestTargetNode {
    /**
     * 
     * @type {string}
     * @memberof ModelRequestTargetNode
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRequestTargetNode
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRequestTargetNode
     */
    'kind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelRequestTargetNode
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ModelRequestTargetStatistics
 */
export interface ModelRequestTargetStatistics {
    /**
     * 
     * @type {number}
     * @memberof ModelRequestTargetStatistics
     */
    'num_pd_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelRequestTargetStatistics
     */
    'num_tidb_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelRequestTargetStatistics
     */
    'num_tiflash_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelRequestTargetStatistics
     */
    'num_tikv_nodes'?: number;
}
/**
 * 
 * @export
 * @interface ProfilingGroupDetailResponse
 */
export interface ProfilingGroupDetailResponse {
    /**
     * 
     * @type {number}
     * @memberof ProfilingGroupDetailResponse
     */
    'server_time'?: number;
    /**
     * 
     * @type {ProfilingTaskGroupModel}
     * @memberof ProfilingGroupDetailResponse
     */
    'task_group_status'?: ProfilingTaskGroupModel;
    /**
     * 
     * @type {Array<ProfilingTaskModel>}
     * @memberof ProfilingGroupDetailResponse
     */
    'tasks_status'?: Array<ProfilingTaskModel>;
}
/**
 * 
 * @export
 * @interface ProfilingStartRequest
 */
export interface ProfilingStartRequest {
    /**
     * 
     * @type {number}
     * @memberof ProfilingStartRequest
     */
    'duration_secs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfilingStartRequest
     */
    'requsted_profiling_types'?: Array<string>;
    /**
     * 
     * @type {Array<ModelRequestTargetNode>}
     * @memberof ProfilingStartRequest
     */
    'targets'?: Array<ModelRequestTargetNode>;
}
/**
 * 
 * @export
 * @interface ProfilingTaskGroupModel
 */
export interface ProfilingTaskGroupModel {
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    'profile_duration_secs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfilingTaskGroupModel
     */
    'requsted_profiling_types'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    'started_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskGroupModel
     */
    'state'?: number;
    /**
     * 
     * @type {ModelRequestTargetStatistics}
     * @memberof ProfilingTaskGroupModel
     */
    'target_stats'?: ModelRequestTargetStatistics;
}
/**
 * 
 * @export
 * @interface ProfilingTaskModel
 */
export interface ProfilingTaskModel {
    /**
     * 
     * @type {string}
     * @memberof ProfilingTaskModel
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfilingTaskModel
     */
    'profiling_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilingTaskModel
     */
    'raw_data_type'?: string;
    /**
     * The start running time, reset when retry. Used to estimate approximate profiling progress.
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    'started_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    'state'?: number;
    /**
     * 
     * @type {ModelRequestTargetNode}
     * @memberof ProfilingTaskModel
     */
    'target'?: ModelRequestTargetNode;
    /**
     * 
     * @type {number}
     * @memberof ProfilingTaskModel
     */
    'task_group_id'?: number;
}
/**
 * 
 * @export
 * @interface QueryeditorRunRequest
 */
export interface QueryeditorRunRequest {
    /**
     * 
     * @type {number}
     * @memberof QueryeditorRunRequest
     */
    'max_rows'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryeditorRunRequest
     */
    'statements'?: string;
}
/**
 * 
 * @export
 * @interface QueryeditorRunResponse
 */
export interface QueryeditorRunResponse {
    /**
     * 
     * @type {number}
     * @memberof QueryeditorRunResponse
     */
    'actual_rows'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryeditorRunResponse
     */
    'column_names'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QueryeditorRunResponse
     */
    'error_msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryeditorRunResponse
     */
    'execution_ms'?: number;
    /**
     * 
     * @type {Array<Array<object>>}
     * @memberof QueryeditorRunResponse
     */
    'rows'?: Array<Array<object>>;
}
/**
 * 
 * @export
 * @interface RestErrorResponse
 */
export interface RestErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof RestErrorResponse
     */
    'code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RestErrorResponse
     */
    'error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestErrorResponse
     */
    'full_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestErrorResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SlowqueryGetListRequest
 */
export interface SlowqueryGetListRequest {
    /**
     * 
     * @type {number}
     * @memberof SlowqueryGetListRequest
     */
    'begin_time'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlowqueryGetListRequest
     */
    'db'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SlowqueryGetListRequest
     */
    'desc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryGetListRequest
     */
    'digest'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryGetListRequest
     */
    'end_time'?: number;
    /**
     * example: \"Query,Digest\"
     * @type {string}
     * @memberof SlowqueryGetListRequest
     */
    'fields'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryGetListRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryGetListRequest
     */
    'orderBy'?: string;
    /**
     * for showing slow queries in the statement detail page
     * @type {Array<string>}
     * @memberof SlowqueryGetListRequest
     */
    'plans'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryGetListRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SlowqueryModel
 */
export interface SlowqueryModel {
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'backoff_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'backoff_types'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'commit_backoff_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'commit_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'compile_time'?: number;
    /**
     * TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
     * @type {string}
     * @memberof SlowqueryModel
     */
    'connection_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'cop_proc_addr'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_proc_avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_proc_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_proc_p90'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'cop_wait_addr'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_wait_avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_wait_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'cop_wait_p90'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'db'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'digest'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'disk_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'exec_retry_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'get_commit_ts_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'index_names'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'instance'?: string;
    /**
     * Basic
     * @type {number}
     * @memberof SlowqueryModel
     */
    'is_internal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'local_latch_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'lock_keys_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'memory_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'optimize_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'parse_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'plan'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'preproc_subqueries_time'?: number;
    /**
     * Detail
     * @type {string}
     * @memberof SlowqueryModel
     */
    'prev_stmt'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'prewrite_region'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'prewrite_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'process_keys'?: number;
    /**
     * Time
     * @type {number}
     * @memberof SlowqueryModel
     */
    'process_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'query'?: string;
    /**
     * latency
     * @type {number}
     * @memberof SlowqueryModel
     */
    'query_time'?: number;
    /**
     * Coprocessor
     * @type {number}
     * @memberof SlowqueryModel
     */
    'request_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'resolve_lock_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rewrite_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rocksdb_block_cache_hit_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rocksdb_block_read_byte'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rocksdb_block_read_count'?: number;
    /**
     * RocksDB
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rocksdb_delete_skipped_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'rocksdb_key_skipped_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowqueryModel
     */
    'stats'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'success'?: number;
    /**
     * finish time
     * @type {number}
     * @memberof SlowqueryModel
     */
    'timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'total_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'txn_retry'?: number;
    /**
     * TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
     * @type {string}
     * @memberof SlowqueryModel
     */
    'txn_start_ts'?: string;
    /**
     * Connection
     * @type {string}
     * @memberof SlowqueryModel
     */
    'user'?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'wait_prewrite_binlog_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'wait_ts'?: number;
    /**
     * Transaction
     * @type {number}
     * @memberof SlowqueryModel
     */
    'write_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'write_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowqueryModel
     */
    'write_sql_response_total'?: number;
}
/**
 * 
 * @export
 * @interface SsoCreateImpersonationRequest
 */
export interface SsoCreateImpersonationRequest {
    /**
     * 
     * @type {string}
     * @memberof SsoCreateImpersonationRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SsoCreateImpersonationRequest
     */
    'sql_user'?: string;
}
/**
 * 
 * @export
 * @interface SsoSSOImpersonationModel
 */
export interface SsoSSOImpersonationModel {
    /**
     * 
     * @type {string}
     * @memberof SsoSSOImpersonationModel
     */
    'last_impersonate_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SsoSSOImpersonationModel
     */
    'sql_user'?: string;
}
/**
 * 
 * @export
 * @interface SsoSetConfigRequest
 */
export interface SsoSetConfigRequest {
    /**
     * 
     * @type {ConfigSSOCoreConfig}
     * @memberof SsoSetConfigRequest
     */
    'config'?: ConfigSSOCoreConfig;
}
/**
 * 
 * @export
 * @interface StatementEditableConfig
 */
export interface StatementEditableConfig {
    /**
     * 
     * @type {boolean}
     * @memberof StatementEditableConfig
     */
    'enable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StatementEditableConfig
     */
    'history_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StatementEditableConfig
     */
    'internal_query'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StatementEditableConfig
     */
    'max_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementEditableConfig
     */
    'refresh_interval'?: number;
}
/**
 * 
 * @export
 * @interface StatementGetStatementsRequest
 */
export interface StatementGetStatementsRequest {
    /**
     * 
     * @type {number}
     * @memberof StatementGetStatementsRequest
     */
    'begin_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementGetStatementsRequest
     */
    'end_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementGetStatementsRequest
     */
    'fields'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatementGetStatementsRequest
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatementGetStatementsRequest
     */
    'stmt_types'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StatementGetStatementsRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface StatementModel
 */
export interface StatementModel {
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_affected_rows'?: number;
    /**
     * avg total back off time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'avg_backoff_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_commit_backoff_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_commit_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_compile_latency'?: number;
    /**
     * avg process time per copr task
     * @type {number}
     * @memberof StatementModel
     */
    'avg_cop_process_time'?: number;
    /**
     * avg wait time per copr task
     * @type {number}
     * @memberof StatementModel
     */
    'avg_cop_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_disk'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_get_commit_ts_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_local_latch_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_mem'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_parse_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_prewrite_regions'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_prewrite_time'?: number;
    /**
     * avg total process time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'avg_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_processed_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_resolve_lock_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_rocksdb_block_cache_hit_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_rocksdb_block_read_byte'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_rocksdb_block_read_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_rocksdb_delete_skipped_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_rocksdb_key_skipped_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_total_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_txn_retry'?: number;
    /**
     * avg total wait time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'avg_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_write_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'avg_write_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'digest'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'digest_text'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'exec_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'first_seen'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'index_names'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'last_seen'?: number;
    /**
     * max back off time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'max_backoff_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_commit_backoff_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_commit_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_compile_latency'?: number;
    /**
     * max process time per copr task
     * @type {number}
     * @memberof StatementModel
     */
    'max_cop_process_time'?: number;
    /**
     * max wait time per copr task
     * @type {number}
     * @memberof StatementModel
     */
    'max_cop_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_disk'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_get_commit_ts_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_local_latch_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_mem'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_parse_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_prewrite_regions'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_prewrite_time'?: number;
    /**
     * max process time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'max_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_processed_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_resolve_lock_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_rocksdb_block_cache_hit_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_rocksdb_block_read_byte'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_rocksdb_block_read_count'?: number;
    /**
     * RocksDB
     * @type {number}
     * @memberof StatementModel
     */
    'max_rocksdb_delete_skipped_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_rocksdb_key_skipped_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_total_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_txn_retry'?: number;
    /**
     * max wait time per sql
     * @type {number}
     * @memberof StatementModel
     */
    'max_wait_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_write_keys'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'max_write_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'min_latency'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'plan'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'plan_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'plan_digest'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'prev_sample_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'query_sample_text'?: string;
    /**
     * Computed fields
     * @type {string}
     * @memberof StatementModel
     */
    'related_schemas'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'sample_user'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'schema_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'sum_backoff_times'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'sum_cop_task_num'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'sum_errors'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'sum_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementModel
     */
    'sum_warnings'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatementModel
     */
    'table_names'?: string;
}
/**
 * 
 * @export
 * @interface StatementTimeRange
 */
export interface StatementTimeRange {
    /**
     * 
     * @type {number}
     * @memberof StatementTimeRange
     */
    'begin_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatementTimeRange
     */
    'end_time'?: number;
}
/**
 * 
 * @export
 * @interface TopologyAlertManagerInfo
 */
export interface TopologyAlertManagerInfo {
    /**
     * 
     * @type {string}
     * @memberof TopologyAlertManagerInfo
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopologyAlertManagerInfo
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface TopologyGrafanaInfo
 */
export interface TopologyGrafanaInfo {
    /**
     * 
     * @type {string}
     * @memberof TopologyGrafanaInfo
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopologyGrafanaInfo
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface TopologyPDInfo
 */
export interface TopologyPDInfo {
    /**
     * 
     * @type {string}
     * @memberof TopologyPDInfo
     */
    'deploy_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyPDInfo
     */
    'git_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyPDInfo
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopologyPDInfo
     */
    'port'?: number;
    /**
     * Ts = 0 means unknown
     * @type {number}
     * @memberof TopologyPDInfo
     */
    'start_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyPDInfo
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopologyPDInfo
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TopologyStoreInfo
 */
export interface TopologyStoreInfo {
    /**
     * 
     * @type {string}
     * @memberof TopologyStoreInfo
     */
    'deploy_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyStoreInfo
     */
    'git_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyStoreInfo
     */
    'ip'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TopologyStoreInfo
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof TopologyStoreInfo
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyStoreInfo
     */
    'start_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyStoreInfo
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyStoreInfo
     */
    'status_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopologyStoreInfo
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TopologyStoreLabels
 */
export interface TopologyStoreLabels {
    /**
     * 
     * @type {string}
     * @memberof TopologyStoreLabels
     */
    'address'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TopologyStoreLabels
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TopologyStoreLocation
 */
export interface TopologyStoreLocation {
    /**
     * 
     * @type {Array<string>}
     * @memberof TopologyStoreLocation
     */
    'location_labels'?: Array<string>;
    /**
     * 
     * @type {Array<TopologyStoreLabels>}
     * @memberof TopologyStoreLocation
     */
    'stores'?: Array<TopologyStoreLabels>;
}
/**
 * 
 * @export
 * @interface TopologyTiDBInfo
 */
export interface TopologyTiDBInfo {
    /**
     * 
     * @type {string}
     * @memberof TopologyTiDBInfo
     */
    'deploy_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyTiDBInfo
     */
    'git_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopologyTiDBInfo
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopologyTiDBInfo
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyTiDBInfo
     */
    'start_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyTiDBInfo
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopologyTiDBInfo
     */
    'status_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopologyTiDBInfo
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TopsqlEditableConfig
 */
export interface TopsqlEditableConfig {
    /**
     * 
     * @type {boolean}
     * @memberof TopsqlEditableConfig
     */
    'enable'?: boolean;
}
/**
 * 
 * @export
 * @interface TopsqlInstanceItem
 */
export interface TopsqlInstanceItem {
    /**
     * 
     * @type {string}
     * @memberof TopsqlInstanceItem
     */
    'instance'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopsqlInstanceItem
     */
    'instance_type'?: string;
}
/**
 * 
 * @export
 * @interface TopsqlInstanceResponse
 */
export interface TopsqlInstanceResponse {
    /**
     * 
     * @type {Array<TopsqlInstanceItem>}
     * @memberof TopsqlInstanceResponse
     */
    'data'?: Array<TopsqlInstanceItem>;
}
/**
 * 
 * @export
 * @interface TopsqlSummaryItem
 */
export interface TopsqlSummaryItem {
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryItem
     */
    'cpu_time_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryItem
     */
    'duration_per_exec_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryItem
     */
    'exec_count_per_sec'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TopsqlSummaryItem
     */
    'is_other'?: boolean;
    /**
     * 
     * @type {Array<TopsqlSummaryPlanItem>}
     * @memberof TopsqlSummaryItem
     */
    'plans'?: Array<TopsqlSummaryPlanItem>;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryItem
     */
    'scan_indexes_per_sec'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryItem
     */
    'scan_records_per_sec'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopsqlSummaryItem
     */
    'sql_digest'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopsqlSummaryItem
     */
    'sql_text'?: string;
}
/**
 * 
 * @export
 * @interface TopsqlSummaryPlanItem
 */
export interface TopsqlSummaryPlanItem {
    /**
     * 
     * @type {Array<number>}
     * @memberof TopsqlSummaryPlanItem
     */
    'cpu_time_ms'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryPlanItem
     */
    'duration_per_exec_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryPlanItem
     */
    'exec_count_per_sec'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopsqlSummaryPlanItem
     */
    'plan_digest'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopsqlSummaryPlanItem
     */
    'plan_text'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryPlanItem
     */
    'scan_indexes_per_sec'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopsqlSummaryPlanItem
     */
    'scan_records_per_sec'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof TopsqlSummaryPlanItem
     */
    'timestamp_sec'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TopsqlSummaryResponse
 */
export interface TopsqlSummaryResponse {
    /**
     * 
     * @type {Array<TopsqlSummaryItem>}
     * @memberof TopsqlSummaryResponse
     */
    'data'?: Array<TopsqlSummaryItem>;
}
/**
 * 
 * @export
 * @interface UserAuthenticateForm
 */
export interface UserAuthenticateForm {
    /**
     * FIXME: Use strong type
     * @type {string}
     * @memberof UserAuthenticateForm
     */
    'extra'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticateForm
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserAuthenticateForm
     */
    'type'?: number;
    /**
     * Does not present for AuthTypeSharingCode
     * @type {string}
     * @memberof UserAuthenticateForm
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface UserGetLoginInfoResponse
 */
export interface UserGetLoginInfoResponse {
    /**
     * 
     * @type {Array<number>}
     * @memberof UserGetLoginInfoResponse
     */
    'supported_auth_types'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserSignOutInfo
 */
export interface UserSignOutInfo {
    /**
     * 
     * @type {string}
     * @memberof UserSignOutInfo
     */
    'end_session_url'?: string;
}
/**
 * 
 * @export
 * @interface UserTokenResponse
 */
export interface UserTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof UserTokenResponse
     */
    'expire'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTokenResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'build_git_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'build_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'internal_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'pd_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    'standalone'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('cancelProfilingGroup', 'groupId', groupId)
            const localVarPath = `/profiling/group/cancel/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetHostsInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/host/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetStatistics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/host/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationEdit: async (request: ConfigurationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('configurationEdit', 'request', request)
            const localVarPath = `/configuration/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configuration/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingActionTokenGet: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('continuousProfilingActionTokenGet', 'q', q)
            const localVarPath = `/continuous_profiling/action_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingComponentsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigPost: async (request: ConprofNgMonitoringConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('continuousProfilingConfigPost', 'request', request)
            const localVarPath = `/continuous_profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingDownloadGet: async (ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('continuousProfilingDownloadGet', 'ts', ts)
            const localVarPath = `/continuous_profiling/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingEstimateSizeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/estimate_size`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfileDetailGet: async (ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('continuousProfilingGroupProfileDetailGet', 'ts', ts)
            const localVarPath = `/continuous_profiling/group_profile/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfilesGet: async (beginTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/group_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingSingleProfileViewGet: async (address?: string, component?: string, profileType?: string, ts?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/single_profile/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (profileType !== undefined) {
                localVarQueryParameter['profile_type'] = profileType;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIGetEndpoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/debug_api/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIRequestEndpoint: async (req: EndpointRequestPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('debugAPIRequestEndpoint', 'req', req)
            const localVarPath = `/debug_api/endpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugApiDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('debugApiDownloadGet', 'token', token)
            const localVarPath = `/debug_api/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteProfilingGroup', 'groupId', groupId)
            const localVarPath = `/profiling/group/delete/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseDiagnosisPost: async (request: DiagnoseGenDiagnosisReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseDiagnosisPost', 'request', request)
            const localVarPath = `/diagnose/diagnosis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseGenerateMetricsRelationship: async (request: DiagnoseGenerateMetricsRelationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseGenerateMetricsRelationship', 'request', request)
            const localVarPath = `/diagnose/metrics_relation/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseMetricsRelationViewGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('diagnoseMetricsRelationViewGet', 'token', token)
            const localVarPath = `/diagnose/metrics_relation/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/diagnose/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDataJsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdDataJsGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/data.js`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDetailGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdDetailGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/detail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdStatusGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost: async (request: DiagnoseGenerateReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseReportsPost', 'request', request)
            const localVarPath = `/diagnose/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('downloadProfilingGroup', 'token', token)
            const localVarPath = `/profiling/group/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('downloadProfilingSingle', 'token', token)
            const localVarPath = `/profiling/single/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionToken: async (id?: string, action?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/action_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerCounts: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAlertManagerCounts', 'address', address)
            const localVarPath = `/topology/alertmanager/{address}/count`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/alertmanager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrafanaTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/grafana`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPDTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/pd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getProfilingGroupDetail', 'groupId', groupId)
            const localVarPath = `/profiling/group/detail/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/group/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreLocationTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/store_location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiDBTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/tidb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListDatabases: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListTables: async (databaseName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (databaseName !== undefined) {
                localVarQueryParameter['database_name'] = databaseName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keyvisual/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigPut: async (request: ConfigKeyVisualConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('keyvisualConfigPut', 'request', request)
            const localVarPath = `/keyvisual/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet: async (startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keyvisual/heatmaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startkey !== undefined) {
                localVarQueryParameter['startkey'] = startkey;
            }

            if (endkey !== undefined) {
                localVarQueryParameter['endkey'] = endkey;
            }

            if (starttime !== undefined) {
                localVarQueryParameter['starttime'] = starttime;
            }

            if (endtime !== undefined) {
                localVarQueryParameter['endtime'] = endtime;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/download/acquire_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('logsDownloadGet', 'token', token)
            const localVarPath = `/logs/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut: async (request: LogsearchCreateTaskGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('logsTaskgroupPut', 'request', request)
            const localVarPath = `/logs/taskgroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/taskgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdCancelPost', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdDelete', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdGet', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdPreviewGet', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdRetryPost', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGetPromAddress: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/prom_address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsQueryGet: async (endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endTimeSec !== undefined) {
                localVarQueryParameter['end_time_sec'] = endTimeSec;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTimeSec !== undefined) {
                localVarQueryParameter['start_time_sec'] = startTimeSec;
            }

            if (stepSec !== undefined) {
                localVarQueryParameter['step_sec'] = stepSec;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsSetCustomPromAddress: async (request: MetricsPutCustomPromAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('metricsSetCustomPromAddress', 'request', request)
            const localVarPath = `/metrics/prom_address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigPut: async (request: ConfigProfilingConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('profilingConfigPut', 'request', request)
            const localVarPath = `/profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryEditorRun: async (request: QueryeditorRunRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('queryEditorRun', 'request', request)
            const localVarPath = `/query_editor/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryAvailableFieldsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/available_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDetailGet: async (connectId?: string, digest?: string, timestamp?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (connectId !== undefined) {
                localVarQueryParameter['connect_id'] = connectId;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('slowQueryDownloadGet', 'token', token)
            const localVarPath = `/slow_query/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadTokenPost: async (request: SlowqueryGetListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('slowQueryDownloadTokenPost', 'request', request)
            const localVarPath = `/slow_query/download/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryListGet: async (beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, text?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (db) {
                localVarQueryParameter['db'] = db;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (plans) {
                localVarQueryParameter['plans'] = plans;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling: async (req: ProfilingStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('startProfiling', 'req', req)
            const localVarPath = `/profiling/group/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsAvailableFieldsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/available_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigPost: async (request: StatementEditableConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('statementsConfigPost', 'request', request)
            const localVarPath = `/statements/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('statementsDownloadGet', 'token', token)
            const localVarPath = `/statements/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadTokenPost: async (request: StatementGetStatementsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('statementsDownloadTokenPost', 'request', request)
            const localVarPath = `/statements/download/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsListGet: async (beginTime?: number, endTime?: number, fields?: string, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (schemas) {
                localVarQueryParameter['schemas'] = schemas;
            }

            if (stmtTypes) {
                localVarQueryParameter['stmt_types'] = stmtTypes;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanDetailGet: async (beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/plan/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (plans) {
                localVarQueryParameter['plans'] = plans;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlansGet: async (beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsStmtTypesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/stmt_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsTimeRangesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/time_ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyTidbAddressDelete: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('topologyTidbAddressDelete', 'address', address)
            const localVarPath = `/topology/tidb/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigPost: async (request: TopsqlEditableConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('topsqlConfigPost', 'request', request)
            const localVarPath = `/topsql/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlInstancesGet: async (end?: string, start?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlSummaryGet: async (end?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (instance !== undefined) {
                localVarQueryParameter['instance'] = instance;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLoginInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSignOutInfo: async (redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sign_out_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirect_url'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (message: UserAuthenticateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('userLogin', 'message', message)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOCreateImpersonation: async (request: SsoCreateImpersonationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userSSOCreateImpersonation', 'request', request)
            const localVarPath = `/user/sso/impersonation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetAuthURL: async (codeVerifier?: string, redirectUrl?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/auth_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (codeVerifier !== undefined) {
                localVarQueryParameter['code_verifier'] = codeVerifier;
            }

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirect_url'] = redirectUrl;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOListImpersonations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/impersonations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOSetConfig: async (request: SsoSetConfigRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userSSOSetConfig', 'request', request)
            const localVarPath = `/user/sso/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareSession: async (request: CodeShareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userShareSession', 'request', request)
            const localVarPath = `/user/share/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProfilingSingle: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('viewProfilingSingle', 'token', token)
            const localVarPath = `/profiling/single/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelProfilingGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelProfilingGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterInfoGetHostsInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoGetHostsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterInfoGetHostsInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterInfoGetStatistics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoClusterStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterInfoGetStatistics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationEdit(request: ConfigurationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationEditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configurationEdit(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationAllConfigItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configurationGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingActionTokenGet(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingActionTokenGet(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingComponentsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConprofComponent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingComponentsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofNgMonitoringConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingConfigPost(request: ConprofNgMonitoringConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingDownloadGet(ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingDownloadGet(ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingEstimateSizeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofEstimateSizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingEstimateSizeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingGroupProfileDetailGet(ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofGroupProfileDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingGroupProfileDetailGet(ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingGroupProfilesGet(beginTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConprofGroupProfiles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingGroupProfilesGet(beginTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingSingleProfileViewGet(address?: string, component?: string, profileType?: string, ts?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingSingleProfileViewGet(address, component, profileType, ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugAPIGetEndpoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EndpointAPIDefinition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugAPIGetEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugAPIRequestEndpoint(req: EndpointRequestPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugAPIRequestEndpoint(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugApiDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugApiDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfilingGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfilingGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseDiagnosisPost(request: DiagnoseGenDiagnosisReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseTableDef>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseDiagnosisPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseGenerateMetricsRelationship(request: DiagnoseGenerateMetricsRelationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseGenerateMetricsRelationship(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseMetricsRelationViewGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseMetricsRelationViewGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiagnoseReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdDataJsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdDataJsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdDetailGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdDetailGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdStatusGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdStatusGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProfilingGroup(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProfilingGroup(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProfilingSingle(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProfilingSingle(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionToken(id?: string, action?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionToken(id, action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertManagerCounts(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertManagerCounts(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertManagerTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyAlertManagerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertManagerTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrafanaTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyGrafanaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrafanaTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPDTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyPDInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPDTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingGroupDetail(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingGroupDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilingGroupDetail(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfilingTaskGroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilingGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreLocationTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyStoreLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreLocationTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoStoreTopologyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiDBTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyTiDBInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiDBTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoListDatabases(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoListDatabases(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoListTables(databaseName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InfoTableSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoListTables(databaseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoWhoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoWhoAmIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoWhoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigKeyVisualConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualConfigPut(request: ConfigKeyVisualConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigKeyVisualConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualConfigPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatrixMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsDownloadAcquireTokenGet(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsDownloadAcquireTokenGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchTaskGroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdCancelPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdCancelPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdPreviewGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchPreviewModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdPreviewGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdRetryPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdRetryPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGetPromAddress(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGetPromAddressConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGetPromAddress(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsQueryGet(endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsQueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsQueryGet(endTimeSec, query, startTimeSec, stepSec, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsSetCustomPromAddress(request: MetricsPutCustomPromAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsPutCustomPromAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsSetCustomPromAddress(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigProfilingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilingConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingConfigPut(request: ConfigProfilingConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigProfilingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilingConfigPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryEditorRun(request: QueryeditorRunRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryeditorRunResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryEditorRun(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryAvailableFieldsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryAvailableFieldsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDetailGet(connectId?: string, digest?: string, timestamp?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlowqueryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDetailGet(connectId, digest, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDownloadTokenPost(request: SlowqueryGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDownloadTokenPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryListGet(beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, text?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlowqueryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryListGet(beginTime, db, desc, digest, endTime, fields, limit, orderBy, plans, text, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProfiling(req: ProfilingStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingTaskGroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProfiling(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsAvailableFieldsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsAvailableFieldsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementEditableConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsConfigPost(request: StatementEditableConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsDownloadTokenPost(request: StatementGetStatementsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsDownloadTokenPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsListGet(beginTime?: number, endTime?: number, fields?: string, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsListGet(beginTime, endTime, fields, schemas, stmtTypes, text, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlanDetailGet(beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlanDetailGet(beginTime, digest, endTime, plans, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlansGet(beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlansGet(beginTime, digest, endTime, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsStmtTypesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsStmtTypesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsTimeRangesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementTimeRange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsTimeRangesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topologyTidbAddressDelete(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topologyTidbAddressDelete(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlEditableConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlConfigPost(request: TopsqlEditableConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlInstancesGet(end?: string, start?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlInstanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlInstancesGet(end, start, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlSummaryGet(end?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlSummaryGet(end, instance, instanceType, start, top, window, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetLoginInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetLoginInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetLoginInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetSignOutInfo(redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSignOutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetSignOutInfo(redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(message: UserAuthenticateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOCreateImpersonation(request: SsoCreateImpersonationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSSOImpersonationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOCreateImpersonation(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOGetAuthURL(codeVerifier?: string, redirectUrl?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOGetAuthURL(codeVerifier, redirectUrl, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOGetConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSSOCoreConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOGetConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOListImpersonations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SsoSSOImpersonationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOListImpersonations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOSetConfig(request: SsoSetConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSSOCoreConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOSetConfig(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareSession(request: CodeShareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareSession(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewProfilingSingle(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewProfilingSingle(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.cancelProfilingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetHostsInfo(options?: any): AxiosPromise<ClusterinfoGetHostsInfoResponse> {
            return localVarFp.clusterInfoGetHostsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetStatistics(options?: any): AxiosPromise<ClusterinfoClusterStatistics> {
            return localVarFp.clusterInfoGetStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationEdit(request: ConfigurationEditRequest, options?: any): AxiosPromise<ConfigurationEditResponse> {
            return localVarFp.configurationEdit(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGetAll(options?: any): AxiosPromise<ConfigurationAllConfigItems> {
            return localVarFp.configurationGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingActionTokenGet(q: string, options?: any): AxiosPromise<string> {
            return localVarFp.continuousProfilingActionTokenGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingComponentsGet(options?: any): AxiosPromise<Array<ConprofComponent>> {
            return localVarFp.continuousProfilingComponentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigGet(options?: any): AxiosPromise<ConprofNgMonitoringConfig> {
            return localVarFp.continuousProfilingConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigPost(request: ConprofNgMonitoringConfig, options?: any): AxiosPromise<string> {
            return localVarFp.continuousProfilingConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingDownloadGet(ts: number, options?: any): AxiosPromise<void> {
            return localVarFp.continuousProfilingDownloadGet(ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingEstimateSizeGet(options?: any): AxiosPromise<ConprofEstimateSizeRes> {
            return localVarFp.continuousProfilingEstimateSizeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfileDetailGet(ts: number, options?: any): AxiosPromise<ConprofGroupProfileDetail> {
            return localVarFp.continuousProfilingGroupProfileDetailGet(ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfilesGet(beginTime?: number, endTime?: number, options?: any): AxiosPromise<Array<ConprofGroupProfiles>> {
            return localVarFp.continuousProfilingGroupProfilesGet(beginTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingSingleProfileViewGet(address?: string, component?: string, profileType?: string, ts?: number, options?: any): AxiosPromise<void> {
            return localVarFp.continuousProfilingSingleProfileViewGet(address, component, profileType, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIGetEndpoints(options?: any): AxiosPromise<Array<EndpointAPIDefinition>> {
            return localVarFp.debugAPIGetEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIRequestEndpoint(req: EndpointRequestPayload, options?: any): AxiosPromise<string> {
            return localVarFp.debugAPIRequestEndpoint(req, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugApiDownloadGet(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.debugApiDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteProfilingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseDiagnosisPost(request: DiagnoseGenDiagnosisReportRequest, options?: any): AxiosPromise<DiagnoseTableDef> {
            return localVarFp.diagnoseDiagnosisPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseGenerateMetricsRelationship(request: DiagnoseGenerateMetricsRelationRequest, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseGenerateMetricsRelationship(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseMetricsRelationViewGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.diagnoseMetricsRelationViewGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsGet(options?: any): AxiosPromise<Array<DiagnoseReport>> {
            return localVarFp.diagnoseReportsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDataJsGet(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseReportsIdDataJsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDetailGet(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseReportsIdDetailGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet(id: string, options?: any): AxiosPromise<DiagnoseReport> {
            return localVarFp.diagnoseReportsIdStatusGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: any): AxiosPromise<number> {
            return localVarFp.diagnoseReportsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadProfilingGroup(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadProfilingSingle(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionToken(id?: string, action?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getActionToken(id, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerCounts(address: string, options?: any): AxiosPromise<number> {
            return localVarFp.getAlertManagerCounts(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerTopology(options?: any): AxiosPromise<TopologyAlertManagerInfo> {
            return localVarFp.getAlertManagerTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrafanaTopology(options?: any): AxiosPromise<TopologyGrafanaInfo> {
            return localVarFp.getGrafanaTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPDTopology(options?: any): AxiosPromise<Array<TopologyPDInfo>> {
            return localVarFp.getPDTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail(groupId: string, options?: any): AxiosPromise<ProfilingGroupDetailResponse> {
            return localVarFp.getProfilingGroupDetail(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups(options?: any): AxiosPromise<Array<ProfilingTaskGroupModel>> {
            return localVarFp.getProfilingGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreLocationTopology(options?: any): AxiosPromise<TopologyStoreLocation> {
            return localVarFp.getStoreLocationTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTopology(options?: any): AxiosPromise<ClusterinfoStoreTopologyResponse> {
            return localVarFp.getStoreTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiDBTopology(options?: any): AxiosPromise<Array<TopologyTiDBInfo>> {
            return localVarFp.getTiDBTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoGet(options?: any): AxiosPromise<InfoInfoResponse> {
            return localVarFp.infoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListDatabases(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.infoListDatabases(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListTables(databaseName?: string, options?: any): AxiosPromise<Array<InfoTableSchema>> {
            return localVarFp.infoListTables(databaseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoami(options?: any): AxiosPromise<InfoWhoAmIResponse> {
            return localVarFp.infoWhoami(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigGet(options?: any): AxiosPromise<ConfigKeyVisualConfig> {
            return localVarFp.keyvisualConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigPut(request: ConfigKeyVisualConfig, options?: any): AxiosPromise<ConfigKeyVisualConfig> {
            return localVarFp.keyvisualConfigPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: any): AxiosPromise<MatrixMatrix> {
            return localVarFp.keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet(id?: Array<string>, options?: any): AxiosPromise<string> {
            return localVarFp.logsDownloadAcquireTokenGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.logsDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any): AxiosPromise<LogsearchTaskGroupResponse> {
            return localVarFp.logsTaskgroupPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet(options?: any): AxiosPromise<Array<LogsearchTaskGroupModel>> {
            return localVarFp.logsTaskgroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdCancelPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet(id: string, options?: any): AxiosPromise<LogsearchTaskGroupResponse> {
            return localVarFp.logsTaskgroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet(id: string, options?: any): AxiosPromise<Array<LogsearchPreviewModel>> {
            return localVarFp.logsTaskgroupsIdPreviewGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdRetryPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGetPromAddress(options?: any): AxiosPromise<MetricsGetPromAddressConfigResponse> {
            return localVarFp.metricsGetPromAddress(options).then((request) => request(axios, basePath));
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsQueryGet(endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options?: any): AxiosPromise<MetricsQueryResponse> {
            return localVarFp.metricsQueryGet(endTimeSec, query, startTimeSec, stepSec, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsSetCustomPromAddress(request: MetricsPutCustomPromAddressRequest, options?: any): AxiosPromise<MetricsPutCustomPromAddressResponse> {
            return localVarFp.metricsSetCustomPromAddress(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigGet(options?: any): AxiosPromise<ConfigProfilingConfig> {
            return localVarFp.profilingConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigPut(request: ConfigProfilingConfig, options?: any): AxiosPromise<ConfigProfilingConfig> {
            return localVarFp.profilingConfigPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryEditorRun(request: QueryeditorRunRequest, options?: any): AxiosPromise<QueryeditorRunResponse> {
            return localVarFp.queryEditorRun(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryAvailableFieldsGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.slowQueryAvailableFieldsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDetailGet(connectId?: string, digest?: string, timestamp?: number, options?: any): AxiosPromise<SlowqueryModel> {
            return localVarFp.slowQueryDetailGet(connectId, digest, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.slowQueryDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadTokenPost(request: SlowqueryGetListRequest, options?: any): AxiosPromise<string> {
            return localVarFp.slowQueryDownloadTokenPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryListGet(beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, text?: string, options?: any): AxiosPromise<Array<SlowqueryModel>> {
            return localVarFp.slowQueryListGet(beginTime, db, desc, digest, endTime, fields, limit, orderBy, plans, text, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling(req: ProfilingStartRequest, options?: any): AxiosPromise<ProfilingTaskGroupModel> {
            return localVarFp.startProfiling(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsAvailableFieldsGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.statementsAvailableFieldsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigGet(options?: any): AxiosPromise<StatementEditableConfig> {
            return localVarFp.statementsConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigPost(request: StatementEditableConfig, options?: any): AxiosPromise<string> {
            return localVarFp.statementsConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.statementsDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadTokenPost(request: StatementGetStatementsRequest, options?: any): AxiosPromise<string> {
            return localVarFp.statementsDownloadTokenPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsListGet(beginTime?: number, endTime?: number, fields?: string, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options?: any): AxiosPromise<Array<StatementModel>> {
            return localVarFp.statementsListGet(beginTime, endTime, fields, schemas, stmtTypes, text, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanDetailGet(beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options?: any): AxiosPromise<StatementModel> {
            return localVarFp.statementsPlanDetailGet(beginTime, digest, endTime, plans, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlansGet(beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options?: any): AxiosPromise<Array<StatementModel>> {
            return localVarFp.statementsPlansGet(beginTime, digest, endTime, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsStmtTypesGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.statementsStmtTypesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available statement time ranges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsTimeRangesGet(options?: any): AxiosPromise<Array<StatementTimeRange>> {
            return localVarFp.statementsTimeRangesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyTidbAddressDelete(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.topologyTidbAddressDelete(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigGet(options?: any): AxiosPromise<TopsqlEditableConfig> {
            return localVarFp.topsqlConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigPost(request: TopsqlEditableConfig, options?: any): AxiosPromise<string> {
            return localVarFp.topsqlConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlInstancesGet(end?: string, start?: string, options?: any): AxiosPromise<TopsqlInstanceResponse> {
            return localVarFp.topsqlInstancesGet(end, start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlSummaryGet(end?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options?: any): AxiosPromise<TopsqlSummaryResponse> {
            return localVarFp.topsqlSummaryGet(end, instance, instanceType, start, top, window, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLoginInfo(options?: any): AxiosPromise<UserGetLoginInfoResponse> {
            return localVarFp.userGetLoginInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSignOutInfo(redirectUrl?: string, options?: any): AxiosPromise<UserSignOutInfo> {
            return localVarFp.userGetSignOutInfo(redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(message: UserAuthenticateForm, options?: any): AxiosPromise<UserTokenResponse> {
            return localVarFp.userLogin(message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOCreateImpersonation(request: SsoCreateImpersonationRequest, options?: any): AxiosPromise<SsoSSOImpersonationModel> {
            return localVarFp.userSSOCreateImpersonation(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetAuthURL(codeVerifier?: string, redirectUrl?: string, state?: string, options?: any): AxiosPromise<string> {
            return localVarFp.userSSOGetAuthURL(codeVerifier, redirectUrl, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetConfig(options?: any): AxiosPromise<ConfigSSOCoreConfig> {
            return localVarFp.userSSOGetConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOListImpersonations(options?: any): AxiosPromise<Array<SsoSSOImpersonationModel>> {
            return localVarFp.userSSOListImpersonations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOSetConfig(request: SsoSetConfigRequest, options?: any): AxiosPromise<ConfigSSOCoreConfig> {
            return localVarFp.userSSOSetConfig(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareSession(request: CodeShareRequest, options?: any): AxiosPromise<CodeShareResponse> {
            return localVarFp.userShareSession(request, options).then((request) => request(axios, basePath));
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProfilingSingle(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.viewProfilingSingle(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    cancelProfilingGroup(groupId: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get information of all hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    clusterInfoGetHostsInfo(options?: AxiosRequestConfig): AxiosPromise<ClusterinfoGetHostsInfoResponse>;

    /**
     * 
     * @summary Get cluster statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    clusterInfoGetStatistics(options?: AxiosRequestConfig): AxiosPromise<ClusterinfoClusterStatistics>;

    /**
     * 
     * @summary Edit a configuration
     * @param {ConfigurationEditRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    configurationEdit(request: ConfigurationEditRequest, options?: AxiosRequestConfig): AxiosPromise<ConfigurationEditResponse>;

    /**
     * 
     * @summary Get all configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    configurationGetAll(options?: AxiosRequestConfig): AxiosPromise<ConfigurationAllConfigItems>;

    /**
     * 
     * @summary Get action token for download or view profile
     * @param {string} q target query string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingActionTokenGet(q: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get current scraping components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingComponentsGet(options?: AxiosRequestConfig): AxiosPromise<Array<ConprofComponent>>;

    /**
     * 
     * @summary Get Continuous Profiling Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingConfigGet(options?: AxiosRequestConfig): AxiosPromise<ConprofNgMonitoringConfig>;

    /**
     * 
     * @summary Update Continuous Profiling Config
     * @param {ConprofNgMonitoringConfig} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingConfigPost(request: ConprofNgMonitoringConfig, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Download Group Profile files
     * @param {number} ts timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingDownloadGet(ts: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get Estimate Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingEstimateSizeGet(options?: AxiosRequestConfig): AxiosPromise<ConprofEstimateSizeRes>;

    /**
     * 
     * @summary Get Group Profile Detail
     * @param {number} ts timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingGroupProfileDetailGet(ts: number, options?: AxiosRequestConfig): AxiosPromise<ConprofGroupProfileDetail>;

    /**
     * 
     * @summary Get Group Profiles
     * @param {number} [beginTime] 
     * @param {number} [endTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingGroupProfilesGet(beginTime?: number, endTime?: number, options?: AxiosRequestConfig): AxiosPromise<Array<ConprofGroupProfiles>>;

    /**
     * 
     * @summary View Single Profile files
     * @param {string} [address] 
     * @param {string} [component] 
     * @param {string} [profileType] 
     * @param {number} [ts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    continuousProfilingSingleProfileViewGet(address?: string, component?: string, profileType?: string, ts?: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get all endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    debugAPIGetEndpoints(options?: AxiosRequestConfig): AxiosPromise<Array<EndpointAPIDefinition>>;

    /**
     * 
     * @summary Send request remote endpoint and return a token for downloading results
     * @param {EndpointRequestPayload} req request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    debugAPIRequestEndpoint(req: EndpointRequestPayload, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Download a finished request result
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    debugApiDownloadGet(token: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteProfilingGroup(groupId: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DiagnoseGenDiagnosisReportRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseDiagnosisPost(request: DiagnoseGenDiagnosisReportRequest, options?: AxiosRequestConfig): AxiosPromise<DiagnoseTableDef>;

    /**
     * 
     * @summary Generate metrics relationship graph.
     * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseGenerateMetricsRelationship(request: DiagnoseGenerateMetricsRelationRequest, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary View metrics relationship graph.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseMetricsRelationViewGet(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get sql diagnosis reports history
     * @summary SQL diagnosis reports history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseReportsGet(options?: AxiosRequestConfig): AxiosPromise<Array<DiagnoseReport>>;

    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseReportsIdDataJsGet(id: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseReportsIdDetailGet(id: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseReportsIdStatusGet(id: string, options?: AxiosRequestConfig): AxiosPromise<DiagnoseReport>;

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DiagnoseGenerateReportRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: AxiosRequestConfig): AxiosPromise<number>;

    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadProfilingGroup(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadProfilingSingle(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get token with a given group ID or task ID and action type
     * @summary Get action token for download or view
     * @param {string} [id] group or task ID
     * @param {string} [action] action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getActionToken(id?: string, action?: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get current alert count from AlertManager
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getAlertManagerCounts(address: string, options?: AxiosRequestConfig): AxiosPromise<number>;

    /**
     * 
     * @summary Get AlertManager instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getAlertManagerTopology(options?: AxiosRequestConfig): AxiosPromise<TopologyAlertManagerInfo>;

    /**
     * 
     * @summary Get Grafana instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getGrafanaTopology(options?: AxiosRequestConfig): AxiosPromise<TopologyGrafanaInfo>;

    /**
     * 
     * @summary Get all PD instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPDTopology(options?: AxiosRequestConfig): AxiosPromise<Array<TopologyPDInfo>>;

    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getProfilingGroupDetail(groupId: string, options?: AxiosRequestConfig): AxiosPromise<ProfilingGroupDetailResponse>;

    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getProfilingGroups(options?: AxiosRequestConfig): AxiosPromise<Array<ProfilingTaskGroupModel>>;

    /**
     * 
     * @summary Get location labels of all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getStoreLocationTopology(options?: AxiosRequestConfig): AxiosPromise<TopologyStoreLocation>;

    /**
     * 
     * @summary Get all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getStoreTopology(options?: AxiosRequestConfig): AxiosPromise<ClusterinfoStoreTopologyResponse>;

    /**
     * 
     * @summary Get all TiDB instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTiDBTopology(options?: AxiosRequestConfig): AxiosPromise<Array<TopologyTiDBInfo>>;

    /**
     * 
     * @summary Get information about this TiDB Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    infoGet(options?: AxiosRequestConfig): AxiosPromise<InfoInfoResponse>;

    /**
     * 
     * @summary List all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    infoListDatabases(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary List tables by database name
     * @param {string} [databaseName] Database name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    infoListTables(databaseName?: string, options?: AxiosRequestConfig): AxiosPromise<Array<InfoTableSchema>>;

    /**
     * 
     * @summary Get information about current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    infoWhoami(options?: AxiosRequestConfig): AxiosPromise<InfoWhoAmIResponse>;

    /**
     * 
     * @summary Get Key Visual Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    keyvisualConfigGet(options?: AxiosRequestConfig): AxiosPromise<ConfigKeyVisualConfig>;

    /**
     * 
     * @summary Set Key Visual Dynamic Config
     * @param {ConfigKeyVisualConfig} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    keyvisualConfigPut(request: ConfigKeyVisualConfig, options?: AxiosRequestConfig): AxiosPromise<ConfigKeyVisualConfig>;

    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {string} [startkey] The start of the key range
     * @param {string} [endkey] The end of the key range
     * @param {number} [starttime] The start of the time range (Unix)
     * @param {number} [endtime] The end of the time range (Unix)
     * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: AxiosRequestConfig): AxiosPromise<MatrixMatrix>;

    /**
     * 
     * @summary Generate a download token for downloading logs
     * @param {Array<string>} [id] task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsDownloadAcquireTokenGet(id?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Download logs
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsDownloadGet(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create and run a new log search task group
     * @param {LogsearchCreateTaskGroupRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: AxiosRequestConfig): AxiosPromise<LogsearchTaskGroupResponse>;

    /**
     * 
     * @summary List all log search task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsGet(options?: AxiosRequestConfig): AxiosPromise<Array<LogsearchTaskGroupModel>>;

    /**
     * 
     * @summary Cancel running tasks in a log search task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsIdCancelPost(id: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete a log search task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsIdDelete(id: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary List tasks in a log search task group
     * @param {string} id Task Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsIdGet(id: string, options?: AxiosRequestConfig): AxiosPromise<LogsearchTaskGroupResponse>;

    /**
     * 
     * @summary Preview a log search task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsIdPreviewGet(id: string, options?: AxiosRequestConfig): AxiosPromise<Array<LogsearchPreviewModel>>;

    /**
     * 
     * @summary Retry failed tasks in a log search task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    logsTaskgroupsIdRetryPost(id: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get the Prometheus address cluster config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    metricsGetPromAddress(options?: AxiosRequestConfig): AxiosPromise<MetricsGetPromAddressConfigResponse>;

    /**
     * Query metrics in the given range
     * @summary Query metrics
     * @param {number} [endTimeSec] 
     * @param {string} [query] 
     * @param {number} [startTimeSec] 
     * @param {number} [stepSec] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    metricsQueryGet(endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options?: AxiosRequestConfig): AxiosPromise<MetricsQueryResponse>;

    /**
     * 
     * @summary Set or clear the customized Prometheus address
     * @param {MetricsPutCustomPromAddressRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    metricsSetCustomPromAddress(request: MetricsPutCustomPromAddressRequest, options?: AxiosRequestConfig): AxiosPromise<MetricsPutCustomPromAddressResponse>;

    /**
     * 
     * @summary Get Profiling Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    profilingConfigGet(options?: AxiosRequestConfig): AxiosPromise<ConfigProfilingConfig>;

    /**
     * 
     * @summary Set Profiling Dynamic Config
     * @param {ConfigProfilingConfig} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    profilingConfigPut(request: ConfigProfilingConfig, options?: AxiosRequestConfig): AxiosPromise<ConfigProfilingConfig>;

    /**
     * 
     * @summary Run statements
     * @param {QueryeditorRunRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    queryEditorRun(request: QueryeditorRunRequest, options?: AxiosRequestConfig): AxiosPromise<QueryeditorRunResponse>;

    /**
     * Get available field names by slowquery table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    slowQueryAvailableFieldsGet(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Get details of a slow query
     * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
     * @param {string} [digest] 
     * @param {number} [timestamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    slowQueryDetailGet(connectId?: string, digest?: string, timestamp?: number, options?: AxiosRequestConfig): AxiosPromise<SlowqueryModel>;

    /**
     * 
     * @summary Download slow query statements
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    slowQueryDownloadGet(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Generate a download token for exported slow query statements
     * @param {SlowqueryGetListRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    slowQueryDownloadTokenPost(request: SlowqueryGetListRequest, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary List all slow queries
     * @param {number} [beginTime] 
     * @param {Array<string>} [db] 
     * @param {boolean} [desc] 
     * @param {string} [digest] 
     * @param {number} [endTime] 
     * @param {string} [fields] example: \&quot;Query,Digest\&quot;
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {Array<string>} [plans] for showing slow queries in the statement detail page
     * @param {string} [text] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    slowQueryListGet(beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, text?: string, options?: AxiosRequestConfig): AxiosPromise<Array<SlowqueryModel>>;

    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {ProfilingStartRequest} req profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    startProfiling(req: ProfilingStartRequest, options?: AxiosRequestConfig): AxiosPromise<ProfilingTaskGroupModel>;

    /**
     * Get available field names by statements table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsAvailableFieldsGet(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Get statement configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsConfigGet(options?: AxiosRequestConfig): AxiosPromise<StatementEditableConfig>;

    /**
     * 
     * @summary Update statement configurations
     * @param {StatementEditableConfig} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsConfigPost(request: StatementEditableConfig, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Download statements
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsDownloadGet(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Generate a download token for exported statements
     * @param {StatementGetStatementsRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsDownloadTokenPost(request: StatementGetStatementsRequest, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get a list of statements
     * @param {number} [beginTime] 
     * @param {number} [endTime] 
     * @param {string} [fields] 
     * @param {Array<string>} [schemas] 
     * @param {Array<string>} [stmtTypes] 
     * @param {string} [text] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsListGet(beginTime?: number, endTime?: number, fields?: string, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options?: AxiosRequestConfig): AxiosPromise<Array<StatementModel>>;

    /**
     * 
     * @summary Get details of a statement in an execution plan
     * @param {number} [beginTime] 
     * @param {string} [digest] 
     * @param {number} [endTime] 
     * @param {Array<string>} [plans] 
     * @param {string} [schemaName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsPlanDetailGet(beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options?: AxiosRequestConfig): AxiosPromise<StatementModel>;

    /**
     * 
     * @summary Get execution plans of a statement
     * @param {number} [beginTime] 
     * @param {string} [digest] 
     * @param {number} [endTime] 
     * @param {string} [schemaName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsPlansGet(beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options?: AxiosRequestConfig): AxiosPromise<Array<StatementModel>>;

    /**
     * 
     * @summary Get all statement types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsStmtTypesGet(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Get available statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    statementsTimeRangesGet(options?: AxiosRequestConfig): AxiosPromise<Array<StatementTimeRange>>;

    /**
     * 
     * @summary Hide a TiDB instance
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    topologyTidbAddressDelete(address: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get Top SQL config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    topsqlConfigGet(options?: AxiosRequestConfig): AxiosPromise<TopsqlEditableConfig>;

    /**
     * 
     * @summary Update Top SQL config
     * @param {TopsqlEditableConfig} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    topsqlConfigPost(request: TopsqlEditableConfig, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get availiable instances
     * @param {string} [end] 
     * @param {string} [start] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    topsqlInstancesGet(end?: string, start?: string, options?: AxiosRequestConfig): AxiosPromise<TopsqlInstanceResponse>;

    /**
     * 
     * @summary Get summaries
     * @param {string} [end] 
     * @param {string} [instance] 
     * @param {string} [instanceType] 
     * @param {string} [start] 
     * @param {string} [top] 
     * @param {string} [window] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    topsqlSummaryGet(end?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options?: AxiosRequestConfig): AxiosPromise<TopsqlSummaryResponse>;

    /**
     * 
     * @summary Get log in information, like supported authenticate types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userGetLoginInfo(options?: AxiosRequestConfig): AxiosPromise<UserGetLoginInfoResponse>;

    /**
     * 
     * @summary Get sign out info
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userGetSignOutInfo(redirectUrl?: string, options?: AxiosRequestConfig): AxiosPromise<UserSignOutInfo>;

    /**
     * 
     * @summary Log in
     * @param {UserAuthenticateForm} message Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userLogin(message: UserAuthenticateForm, options?: AxiosRequestConfig): AxiosPromise<UserTokenResponse>;

    /**
     * 
     * @summary Create an impersonation
     * @param {SsoCreateImpersonationRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userSSOCreateImpersonation(request: SsoCreateImpersonationRequest, options?: AxiosRequestConfig): AxiosPromise<SsoSSOImpersonationModel>;

    /**
     * 
     * @summary Get SSO Auth URL
     * @param {string} [codeVerifier] 
     * @param {string} [redirectUrl] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userSSOGetAuthURL(codeVerifier?: string, redirectUrl?: string, state?: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get SSO config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userSSOGetConfig(options?: AxiosRequestConfig): AxiosPromise<ConfigSSOCoreConfig>;

    /**
     * 
     * @summary List all impersonations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userSSOListImpersonations(options?: AxiosRequestConfig): AxiosPromise<Array<SsoSSOImpersonationModel>>;

    /**
     * 
     * @summary Set SSO config
     * @param {SsoSetConfigRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userSSOSetConfig(request: SsoSetConfigRequest, options?: AxiosRequestConfig): AxiosPromise<ConfigSSOCoreConfig>;

    /**
     * 
     * @summary Share current session and generate a sharing code
     * @param {CodeShareRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    userShareSession(request: CodeShareRequest, options?: AxiosRequestConfig): AxiosPromise<CodeShareResponse>;

    /**
     * View the finished profiling result of a task
     * @summary View the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    viewProfilingSingle(token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for cancelProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiCancelProfilingGroupRequest
 */
export interface DefaultApiCancelProfilingGroupRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiCancelProfilingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for configurationEdit operation in DefaultApi.
 * @export
 * @interface DefaultApiConfigurationEditRequest
 */
export interface DefaultApiConfigurationEditRequest {
    /**
     * Request body
     * @type {ConfigurationEditRequest}
     * @memberof DefaultApiConfigurationEdit
     */
    readonly request: ConfigurationEditRequest
}

/**
 * Request parameters for continuousProfilingActionTokenGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingActionTokenGetRequest
 */
export interface DefaultApiContinuousProfilingActionTokenGetRequest {
    /**
     * target query string
     * @type {string}
     * @memberof DefaultApiContinuousProfilingActionTokenGet
     */
    readonly q: string
}

/**
 * Request parameters for continuousProfilingConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingConfigPostRequest
 */
export interface DefaultApiContinuousProfilingConfigPostRequest {
    /**
     * Request body
     * @type {ConprofNgMonitoringConfig}
     * @memberof DefaultApiContinuousProfilingConfigPost
     */
    readonly request: ConprofNgMonitoringConfig
}

/**
 * Request parameters for continuousProfilingDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingDownloadGetRequest
 */
export interface DefaultApiContinuousProfilingDownloadGetRequest {
    /**
     * timestamp
     * @type {number}
     * @memberof DefaultApiContinuousProfilingDownloadGet
     */
    readonly ts: number
}

/**
 * Request parameters for continuousProfilingGroupProfileDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingGroupProfileDetailGetRequest
 */
export interface DefaultApiContinuousProfilingGroupProfileDetailGetRequest {
    /**
     * timestamp
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfileDetailGet
     */
    readonly ts: number
}

/**
 * Request parameters for continuousProfilingGroupProfilesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingGroupProfilesGetRequest
 */
export interface DefaultApiContinuousProfilingGroupProfilesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfilesGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfilesGet
     */
    readonly endTime?: number
}

/**
 * Request parameters for continuousProfilingSingleProfileViewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingSingleProfileViewGetRequest
 */
export interface DefaultApiContinuousProfilingSingleProfileViewGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly address?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly component?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly profileType?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly ts?: number
}

/**
 * Request parameters for debugAPIRequestEndpoint operation in DefaultApi.
 * @export
 * @interface DefaultApiDebugAPIRequestEndpointRequest
 */
export interface DefaultApiDebugAPIRequestEndpointRequest {
    /**
     * request payload
     * @type {EndpointRequestPayload}
     * @memberof DefaultApiDebugAPIRequestEndpoint
     */
    readonly req: EndpointRequestPayload
}

/**
 * Request parameters for debugApiDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDebugApiDownloadGetRequest
 */
export interface DefaultApiDebugApiDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDebugApiDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for deleteProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteProfilingGroupRequest
 */
export interface DefaultApiDeleteProfilingGroupRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiDeleteProfilingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for diagnoseDiagnosisPost operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseDiagnosisPostRequest
 */
export interface DefaultApiDiagnoseDiagnosisPostRequest {
    /**
     * Request body
     * @type {DiagnoseGenDiagnosisReportRequest}
     * @memberof DefaultApiDiagnoseDiagnosisPost
     */
    readonly request: DiagnoseGenDiagnosisReportRequest
}

/**
 * Request parameters for diagnoseGenerateMetricsRelationship operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseGenerateMetricsRelationshipRequest
 */
export interface DefaultApiDiagnoseGenerateMetricsRelationshipRequest {
    /**
     * Request body
     * @type {DiagnoseGenerateMetricsRelationRequest}
     * @memberof DefaultApiDiagnoseGenerateMetricsRelationship
     */
    readonly request: DiagnoseGenerateMetricsRelationRequest
}

/**
 * Request parameters for diagnoseMetricsRelationViewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseMetricsRelationViewGetRequest
 */
export interface DefaultApiDiagnoseMetricsRelationViewGetRequest {
    /**
     * token
     * @type {string}
     * @memberof DefaultApiDiagnoseMetricsRelationViewGet
     */
    readonly token: string
}

/**
 * Request parameters for diagnoseReportsIdDataJsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdDataJsGetRequest
 */
export interface DefaultApiDiagnoseReportsIdDataJsGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdDataJsGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsIdDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdDetailGetRequest
 */
export interface DefaultApiDiagnoseReportsIdDetailGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdDetailGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsIdStatusGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdStatusGetRequest
 */
export interface DefaultApiDiagnoseReportsIdStatusGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdStatusGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsPostRequest
 */
export interface DefaultApiDiagnoseReportsPostRequest {
    /**
     * Request body
     * @type {DiagnoseGenerateReportRequest}
     * @memberof DefaultApiDiagnoseReportsPost
     */
    readonly request: DiagnoseGenerateReportRequest
}

/**
 * Request parameters for downloadProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadProfilingGroupRequest
 */
export interface DefaultApiDownloadProfilingGroupRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDownloadProfilingGroup
     */
    readonly token: string
}

/**
 * Request parameters for downloadProfilingSingle operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadProfilingSingleRequest
 */
export interface DefaultApiDownloadProfilingSingleRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDownloadProfilingSingle
     */
    readonly token: string
}

/**
 * Request parameters for getActionToken operation in DefaultApi.
 * @export
 * @interface DefaultApiGetActionTokenRequest
 */
export interface DefaultApiGetActionTokenRequest {
    /**
     * group or task ID
     * @type {string}
     * @memberof DefaultApiGetActionToken
     */
    readonly id?: string

    /**
     * action
     * @type {string}
     * @memberof DefaultApiGetActionToken
     */
    readonly action?: string
}

/**
 * Request parameters for getAlertManagerCounts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAlertManagerCountsRequest
 */
export interface DefaultApiGetAlertManagerCountsRequest {
    /**
     * ip:port
     * @type {string}
     * @memberof DefaultApiGetAlertManagerCounts
     */
    readonly address: string
}

/**
 * Request parameters for getProfilingGroupDetail operation in DefaultApi.
 * @export
 * @interface DefaultApiGetProfilingGroupDetailRequest
 */
export interface DefaultApiGetProfilingGroupDetailRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiGetProfilingGroupDetail
     */
    readonly groupId: string
}

/**
 * Request parameters for infoListTables operation in DefaultApi.
 * @export
 * @interface DefaultApiInfoListTablesRequest
 */
export interface DefaultApiInfoListTablesRequest {
    /**
     * Database name
     * @type {string}
     * @memberof DefaultApiInfoListTables
     */
    readonly databaseName?: string
}

/**
 * Request parameters for keyvisualConfigPut operation in DefaultApi.
 * @export
 * @interface DefaultApiKeyvisualConfigPutRequest
 */
export interface DefaultApiKeyvisualConfigPutRequest {
    /**
     * Request body
     * @type {ConfigKeyVisualConfig}
     * @memberof DefaultApiKeyvisualConfigPut
     */
    readonly request: ConfigKeyVisualConfig
}

/**
 * Request parameters for keyvisualHeatmapsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiKeyvisualHeatmapsGetRequest
 */
export interface DefaultApiKeyvisualHeatmapsGetRequest {
    /**
     * The start of the key range
     * @type {string}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly startkey?: string

    /**
     * The end of the key range
     * @type {string}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly endkey?: string

    /**
     * The start of the time range (Unix)
     * @type {number}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly starttime?: number

    /**
     * The end of the time range (Unix)
     * @type {number}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly endtime?: number

    /**
     * Main types of data
     * @type {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'
}

/**
 * Request parameters for logsDownloadAcquireTokenGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsDownloadAcquireTokenGetRequest
 */
export interface DefaultApiLogsDownloadAcquireTokenGetRequest {
    /**
     * task id
     * @type {Array<string>}
     * @memberof DefaultApiLogsDownloadAcquireTokenGet
     */
    readonly id?: Array<string>
}

/**
 * Request parameters for logsDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsDownloadGetRequest
 */
export interface DefaultApiLogsDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiLogsDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for logsTaskgroupPut operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupPutRequest
 */
export interface DefaultApiLogsTaskgroupPutRequest {
    /**
     * Request body
     * @type {LogsearchCreateTaskGroupRequest}
     * @memberof DefaultApiLogsTaskgroupPut
     */
    readonly request: LogsearchCreateTaskGroupRequest
}

/**
 * Request parameters for logsTaskgroupsIdCancelPost operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdCancelPostRequest
 */
export interface DefaultApiLogsTaskgroupsIdCancelPostRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdCancelPost
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdDeleteRequest
 */
export interface DefaultApiLogsTaskgroupsIdDeleteRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdGetRequest
 */
export interface DefaultApiLogsTaskgroupsIdGetRequest {
    /**
     * Task Group ID
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdGet
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdPreviewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdPreviewGetRequest
 */
export interface DefaultApiLogsTaskgroupsIdPreviewGetRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdPreviewGet
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdRetryPost operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdRetryPostRequest
 */
export interface DefaultApiLogsTaskgroupsIdRetryPostRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdRetryPost
     */
    readonly id: string
}

/**
 * Request parameters for metricsQueryGet operation in DefaultApi.
 * @export
 * @interface DefaultApiMetricsQueryGetRequest
 */
export interface DefaultApiMetricsQueryGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly endTimeSec?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly query?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly startTimeSec?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly stepSec?: number
}

/**
 * Request parameters for metricsSetCustomPromAddress operation in DefaultApi.
 * @export
 * @interface DefaultApiMetricsSetCustomPromAddressRequest
 */
export interface DefaultApiMetricsSetCustomPromAddressRequest {
    /**
     * Request body
     * @type {MetricsPutCustomPromAddressRequest}
     * @memberof DefaultApiMetricsSetCustomPromAddress
     */
    readonly request: MetricsPutCustomPromAddressRequest
}

/**
 * Request parameters for profilingConfigPut operation in DefaultApi.
 * @export
 * @interface DefaultApiProfilingConfigPutRequest
 */
export interface DefaultApiProfilingConfigPutRequest {
    /**
     * Request body
     * @type {ConfigProfilingConfig}
     * @memberof DefaultApiProfilingConfigPut
     */
    readonly request: ConfigProfilingConfig
}

/**
 * Request parameters for queryEditorRun operation in DefaultApi.
 * @export
 * @interface DefaultApiQueryEditorRunRequest
 */
export interface DefaultApiQueryEditorRunRequest {
    /**
     * Request body
     * @type {QueryeditorRunRequest}
     * @memberof DefaultApiQueryEditorRun
     */
    readonly request: QueryeditorRunRequest
}

/**
 * Request parameters for slowQueryDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDetailGetRequest
 */
export interface DefaultApiSlowQueryDetailGetRequest {
    /**
     * TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
     * @type {string}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly connectId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly timestamp?: number
}

/**
 * Request parameters for slowQueryDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDownloadGetRequest
 */
export interface DefaultApiSlowQueryDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiSlowQueryDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for slowQueryDownloadTokenPost operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDownloadTokenPostRequest
 */
export interface DefaultApiSlowQueryDownloadTokenPostRequest {
    /**
     * Request body
     * @type {SlowqueryGetListRequest}
     * @memberof DefaultApiSlowQueryDownloadTokenPost
     */
    readonly request: SlowqueryGetListRequest
}

/**
 * Request parameters for slowQueryListGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryListGetRequest
 */
export interface DefaultApiSlowQueryListGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly db?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly desc?: boolean

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly endTime?: number

    /**
     * example: \&quot;Query,Digest\&quot;
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly fields?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly orderBy?: string

    /**
     * for showing slow queries in the statement detail page
     * @type {Array<string>}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly plans?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly text?: string
}

/**
 * Request parameters for startProfiling operation in DefaultApi.
 * @export
 * @interface DefaultApiStartProfilingRequest
 */
export interface DefaultApiStartProfilingRequest {
    /**
     * profiling request
     * @type {ProfilingStartRequest}
     * @memberof DefaultApiStartProfiling
     */
    readonly req: ProfilingStartRequest
}

/**
 * Request parameters for statementsConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsConfigPostRequest
 */
export interface DefaultApiStatementsConfigPostRequest {
    /**
     * Request body
     * @type {StatementEditableConfig}
     * @memberof DefaultApiStatementsConfigPost
     */
    readonly request: StatementEditableConfig
}

/**
 * Request parameters for statementsDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsDownloadGetRequest
 */
export interface DefaultApiStatementsDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiStatementsDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for statementsDownloadTokenPost operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsDownloadTokenPostRequest
 */
export interface DefaultApiStatementsDownloadTokenPostRequest {
    /**
     * Request body
     * @type {StatementGetStatementsRequest}
     * @memberof DefaultApiStatementsDownloadTokenPost
     */
    readonly request: StatementGetStatementsRequest
}

/**
 * Request parameters for statementsListGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsListGetRequest
 */
export interface DefaultApiStatementsListGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsListGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsListGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsListGet
     */
    readonly fields?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsListGet
     */
    readonly schemas?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsListGet
     */
    readonly stmtTypes?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsListGet
     */
    readonly text?: string
}

/**
 * Request parameters for statementsPlanDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlanDetailGetRequest
 */
export interface DefaultApiStatementsPlanDetailGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly plans?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly schemaName?: string
}

/**
 * Request parameters for statementsPlansGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlansGetRequest
 */
export interface DefaultApiStatementsPlansGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly schemaName?: string
}

/**
 * Request parameters for topologyTidbAddressDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiTopologyTidbAddressDeleteRequest
 */
export interface DefaultApiTopologyTidbAddressDeleteRequest {
    /**
     * ip:port
     * @type {string}
     * @memberof DefaultApiTopologyTidbAddressDelete
     */
    readonly address: string
}

/**
 * Request parameters for topsqlConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlConfigPostRequest
 */
export interface DefaultApiTopsqlConfigPostRequest {
    /**
     * Request body
     * @type {TopsqlEditableConfig}
     * @memberof DefaultApiTopsqlConfigPost
     */
    readonly request: TopsqlEditableConfig
}

/**
 * Request parameters for topsqlInstancesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlInstancesGetRequest
 */
export interface DefaultApiTopsqlInstancesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlInstancesGet
     */
    readonly end?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlInstancesGet
     */
    readonly start?: string
}

/**
 * Request parameters for topsqlSummaryGet operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlSummaryGetRequest
 */
export interface DefaultApiTopsqlSummaryGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly end?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly instance?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly instanceType?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly top?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly window?: string
}

/**
 * Request parameters for userGetSignOutInfo operation in DefaultApi.
 * @export
 * @interface DefaultApiUserGetSignOutInfoRequest
 */
export interface DefaultApiUserGetSignOutInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserGetSignOutInfo
     */
    readonly redirectUrl?: string
}

/**
 * Request parameters for userLogin operation in DefaultApi.
 * @export
 * @interface DefaultApiUserLoginRequest
 */
export interface DefaultApiUserLoginRequest {
    /**
     * Credentials
     * @type {UserAuthenticateForm}
     * @memberof DefaultApiUserLogin
     */
    readonly message: UserAuthenticateForm
}

/**
 * Request parameters for userSSOCreateImpersonation operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOCreateImpersonationRequest
 */
export interface DefaultApiUserSSOCreateImpersonationRequest {
    /**
     * Request body
     * @type {SsoCreateImpersonationRequest}
     * @memberof DefaultApiUserSSOCreateImpersonation
     */
    readonly request: SsoCreateImpersonationRequest
}

/**
 * Request parameters for userSSOGetAuthURL operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOGetAuthURLRequest
 */
export interface DefaultApiUserSSOGetAuthURLRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly codeVerifier?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly redirectUrl?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly state?: string
}

/**
 * Request parameters for userSSOSetConfig operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOSetConfigRequest
 */
export interface DefaultApiUserSSOSetConfigRequest {
    /**
     * Request body
     * @type {SsoSetConfigRequest}
     * @memberof DefaultApiUserSSOSetConfig
     */
    readonly request: SsoSetConfigRequest
}

/**
 * Request parameters for userShareSession operation in DefaultApi.
 * @export
 * @interface DefaultApiUserShareSessionRequest
 */
export interface DefaultApiUserShareSessionRequest {
    /**
     * Request body
     * @type {CodeShareRequest}
     * @memberof DefaultApiUserShareSession
     */
    readonly request: CodeShareRequest
}

/**
 * Request parameters for viewProfilingSingle operation in DefaultApi.
 * @export
 * @interface DefaultApiViewProfilingSingleRequest
 */
export interface DefaultApiViewProfilingSingleRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiViewProfilingSingle
     */
    readonly token: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {DefaultApiCancelProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelProfilingGroup(requestParameters: DefaultApiCancelProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelProfilingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information of all hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clusterInfoGetHostsInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clusterInfoGetHostsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clusterInfoGetStatistics(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clusterInfoGetStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a configuration
     * @param {DefaultApiConfigurationEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public configurationEdit(requestParameters: DefaultApiConfigurationEditRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).configurationEdit(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public configurationGetAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).configurationGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get action token for download or view profile
     * @param {DefaultApiContinuousProfilingActionTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingActionTokenGet(requestParameters: DefaultApiContinuousProfilingActionTokenGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingActionTokenGet(requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current scraping components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingComponentsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingComponentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Continuous Profiling Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Continuous Profiling Config
     * @param {DefaultApiContinuousProfilingConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingConfigPost(requestParameters: DefaultApiContinuousProfilingConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Group Profile files
     * @param {DefaultApiContinuousProfilingDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingDownloadGet(requestParameters: DefaultApiContinuousProfilingDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingDownloadGet(requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Estimate Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingEstimateSizeGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingEstimateSizeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group Profile Detail
     * @param {DefaultApiContinuousProfilingGroupProfileDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingGroupProfileDetailGet(requestParameters: DefaultApiContinuousProfilingGroupProfileDetailGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingGroupProfileDetailGet(requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group Profiles
     * @param {DefaultApiContinuousProfilingGroupProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingGroupProfilesGet(requestParameters: DefaultApiContinuousProfilingGroupProfilesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingGroupProfilesGet(requestParameters.beginTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Single Profile files
     * @param {DefaultApiContinuousProfilingSingleProfileViewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingSingleProfileViewGet(requestParameters: DefaultApiContinuousProfilingSingleProfileViewGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingSingleProfileViewGet(requestParameters.address, requestParameters.component, requestParameters.profileType, requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugAPIGetEndpoints(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugAPIGetEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send request remote endpoint and return a token for downloading results
     * @param {DefaultApiDebugAPIRequestEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugAPIRequestEndpoint(requestParameters: DefaultApiDebugAPIRequestEndpointRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugAPIRequestEndpoint(requestParameters.req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a finished request result
     * @param {DefaultApiDebugApiDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugApiDownloadGet(requestParameters: DefaultApiDebugApiDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugApiDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {DefaultApiDeleteProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteProfilingGroup(requestParameters: DefaultApiDeleteProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProfilingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseDiagnosisPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseDiagnosisPost(requestParameters: DefaultApiDiagnoseDiagnosisPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseDiagnosisPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate metrics relationship graph.
     * @param {DefaultApiDiagnoseGenerateMetricsRelationshipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseGenerateMetricsRelationship(requestParameters: DefaultApiDiagnoseGenerateMetricsRelationshipRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseGenerateMetricsRelationship(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View metrics relationship graph.
     * @param {DefaultApiDiagnoseMetricsRelationViewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseMetricsRelationViewGet(requestParameters: DefaultApiDiagnoseMetricsRelationViewGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseMetricsRelationViewGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis reports history
     * @summary SQL diagnosis reports history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {DefaultApiDiagnoseReportsIdDataJsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdDataJsGet(requestParameters: DefaultApiDiagnoseReportsIdDataJsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdDataJsGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseReportsIdDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdDetailGet(requestParameters: DefaultApiDiagnoseReportsIdDetailGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdDetailGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {DefaultApiDiagnoseReportsIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdStatusGet(requestParameters: DefaultApiDiagnoseReportsIdStatusGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdStatusGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseReportsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsPost(requestParameters: DefaultApiDiagnoseReportsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {DefaultApiDownloadProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingGroup(requestParameters: DefaultApiDownloadProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadProfilingGroup(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {DefaultApiDownloadProfilingSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingSingle(requestParameters: DefaultApiDownloadProfilingSingleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadProfilingSingle(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get token with a given group ID or task ID and action type
     * @summary Get action token for download or view
     * @param {DefaultApiGetActionTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActionToken(requestParameters: DefaultApiGetActionTokenRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActionToken(requestParameters.id, requestParameters.action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current alert count from AlertManager
     * @param {DefaultApiGetAlertManagerCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAlertManagerCounts(requestParameters: DefaultApiGetAlertManagerCountsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAlertManagerCounts(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get AlertManager instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAlertManagerTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAlertManagerTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Grafana instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGrafanaTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGrafanaTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all PD instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPDTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPDTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {DefaultApiGetProfilingGroupDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroupDetail(requestParameters: DefaultApiGetProfilingGroupDetailRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProfilingGroupDetail(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroups(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProfilingGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get location labels of all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreLocationTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreLocationTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiDB instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTiDBTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTiDBTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about this TiDB Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoListDatabases(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoListDatabases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tables by database name
     * @param {DefaultApiInfoListTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoListTables(requestParameters: DefaultApiInfoListTablesRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoListTables(requestParameters.databaseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoWhoami(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoWhoami(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Key Visual Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Key Visual Dynamic Config
     * @param {DefaultApiKeyvisualConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualConfigPut(requestParameters: DefaultApiKeyvisualConfigPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualConfigPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {DefaultApiKeyvisualHeatmapsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualHeatmapsGet(requestParameters: DefaultApiKeyvisualHeatmapsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualHeatmapsGet(requestParameters.startkey, requestParameters.endkey, requestParameters.starttime, requestParameters.endtime, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for downloading logs
     * @param {DefaultApiLogsDownloadAcquireTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadAcquireTokenGet(requestParameters: DefaultApiLogsDownloadAcquireTokenGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsDownloadAcquireTokenGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download logs
     * @param {DefaultApiLogsDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadGet(requestParameters: DefaultApiLogsDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and run a new log search task group
     * @param {DefaultApiLogsTaskgroupPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupPut(requestParameters: DefaultApiLogsTaskgroupPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all log search task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel running tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdCancelPost(requestParameters: DefaultApiLogsTaskgroupsIdCancelPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdCancelPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a log search task group
     * @param {DefaultApiLogsTaskgroupsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdDelete(requestParameters: DefaultApiLogsTaskgroupsIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdGet(requestParameters: DefaultApiLogsTaskgroupsIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview a log search task group
     * @param {DefaultApiLogsTaskgroupsIdPreviewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdPreviewGet(requestParameters: DefaultApiLogsTaskgroupsIdPreviewGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdPreviewGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retry failed tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdRetryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdRetryPost(requestParameters: DefaultApiLogsTaskgroupsIdRetryPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdRetryPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus address cluster config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsGetPromAddress(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsGetPromAddress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query metrics in the given range
     * @summary Query metrics
     * @param {DefaultApiMetricsQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsQueryGet(requestParameters: DefaultApiMetricsQueryGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsQueryGet(requestParameters.endTimeSec, requestParameters.query, requestParameters.startTimeSec, requestParameters.stepSec, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or clear the customized Prometheus address
     * @param {DefaultApiMetricsSetCustomPromAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsSetCustomPromAddress(requestParameters: DefaultApiMetricsSetCustomPromAddressRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsSetCustomPromAddress(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Profiling Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilingConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Profiling Dynamic Config
     * @param {DefaultApiProfilingConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingConfigPut(requestParameters: DefaultApiProfilingConfigPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilingConfigPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run statements
     * @param {DefaultApiQueryEditorRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public queryEditorRun(requestParameters: DefaultApiQueryEditorRunRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).queryEditorRun(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available field names by slowquery table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryAvailableFieldsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryAvailableFieldsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a slow query
     * @param {DefaultApiSlowQueryDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDetailGet(requestParameters: DefaultApiSlowQueryDetailGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDetailGet(requestParameters.connectId, requestParameters.digest, requestParameters.timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download slow query statements
     * @param {DefaultApiSlowQueryDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDownloadGet(requestParameters: DefaultApiSlowQueryDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for exported slow query statements
     * @param {DefaultApiSlowQueryDownloadTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDownloadTokenPost(requestParameters: DefaultApiSlowQueryDownloadTokenPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDownloadTokenPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all slow queries
     * @param {DefaultApiSlowQueryListGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryListGet(requestParameters: DefaultApiSlowQueryListGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryListGet(requestParameters.beginTime, requestParameters.db, requestParameters.desc, requestParameters.digest, requestParameters.endTime, requestParameters.fields, requestParameters.limit, requestParameters.orderBy, requestParameters.plans, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {DefaultApiStartProfilingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startProfiling(requestParameters: DefaultApiStartProfilingRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startProfiling(requestParameters.req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available field names by statements table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsAvailableFieldsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsAvailableFieldsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get statement configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update statement configurations
     * @param {DefaultApiStatementsConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsConfigPost(requestParameters: DefaultApiStatementsConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download statements
     * @param {DefaultApiStatementsDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsDownloadGet(requestParameters: DefaultApiStatementsDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for exported statements
     * @param {DefaultApiStatementsDownloadTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsDownloadTokenPost(requestParameters: DefaultApiStatementsDownloadTokenPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsDownloadTokenPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of statements
     * @param {DefaultApiStatementsListGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsListGet(requestParameters: DefaultApiStatementsListGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsListGet(requestParameters.beginTime, requestParameters.endTime, requestParameters.fields, requestParameters.schemas, requestParameters.stmtTypes, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a statement in an execution plan
     * @param {DefaultApiStatementsPlanDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlanDetailGet(requestParameters: DefaultApiStatementsPlanDetailGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlanDetailGet(requestParameters.beginTime, requestParameters.digest, requestParameters.endTime, requestParameters.plans, requestParameters.schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get execution plans of a statement
     * @param {DefaultApiStatementsPlansGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlansGet(requestParameters: DefaultApiStatementsPlansGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlansGet(requestParameters.beginTime, requestParameters.digest, requestParameters.endTime, requestParameters.schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all statement types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsStmtTypesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsStmtTypesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsTimeRangesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsTimeRangesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hide a TiDB instance
     * @param {DefaultApiTopologyTidbAddressDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topologyTidbAddressDelete(requestParameters: DefaultApiTopologyTidbAddressDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topologyTidbAddressDelete(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Top SQL config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Top SQL config
     * @param {DefaultApiTopsqlConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlConfigPost(requestParameters: DefaultApiTopsqlConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get availiable instances
     * @param {DefaultApiTopsqlInstancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlInstancesGet(requestParameters: DefaultApiTopsqlInstancesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlInstancesGet(requestParameters.end, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get summaries
     * @param {DefaultApiTopsqlSummaryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlSummaryGet(requestParameters: DefaultApiTopsqlSummaryGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlSummaryGet(requestParameters.end, requestParameters.instance, requestParameters.instanceType, requestParameters.start, requestParameters.top, requestParameters.window, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get log in information, like supported authenticate types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userGetLoginInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userGetLoginInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sign out info
     * @param {DefaultApiUserGetSignOutInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userGetSignOutInfo(requestParameters: DefaultApiUserGetSignOutInfoRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userGetSignOutInfo(requestParameters.redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in
     * @param {DefaultApiUserLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userLogin(requestParameters: DefaultApiUserLoginRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userLogin(requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an impersonation
     * @param {DefaultApiUserSSOCreateImpersonationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOCreateImpersonation(requestParameters: DefaultApiUserSSOCreateImpersonationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOCreateImpersonation(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SSO Auth URL
     * @param {DefaultApiUserSSOGetAuthURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOGetAuthURL(requestParameters: DefaultApiUserSSOGetAuthURLRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOGetAuthURL(requestParameters.codeVerifier, requestParameters.redirectUrl, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SSO config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOGetConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOGetConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all impersonations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOListImpersonations(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOListImpersonations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set SSO config
     * @param {DefaultApiUserSSOSetConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOSetConfig(requestParameters: DefaultApiUserSSOSetConfigRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOSetConfig(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share current session and generate a sharing code
     * @param {DefaultApiUserShareSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userShareSession(requestParameters: DefaultApiUserShareSessionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userShareSession(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View the finished profiling result of a task
     * @summary View the result of a task
     * @param {DefaultApiViewProfilingSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public viewProfilingSingle(requestParameters: DefaultApiViewProfilingSingleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).viewProfilingSingle(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }
}


