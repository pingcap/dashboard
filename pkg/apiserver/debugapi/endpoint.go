// Copyright 2021 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package debugapi

import (
	"fmt"
	"net/http"
	"net/url"
	"regexp"

	"github.com/pingcap/tidb-dashboard/pkg/apiserver/model"
)

var (
	ErrMissingRequiredParam = ErrNS.NewType("missing_require_parameter")
	ErrInvalidParam         = ErrNS.NewType("invalid_parameter")
)

type ValueGetter interface {
	Get(key string) string
}

type EndpointAPIModel struct {
	ID          string             `json:"id"`
	Component   model.NodeKind     `json:"component"`
	Path        string             `json:"path"`
	Method      EndpointMethod     `json:"method"`
	Host        EndpointAPIParam   `json:"host"`
	PathParams  []EndpointAPIParam `json:"path_params"`  // e.g. /stats/dump/{db}/{table} -> db, table
	QueryParams []EndpointAPIParam `json:"query_params"` // e.g. /debug/pprof?seconds=1 -> seconds
}

type EndpointMethod string

const (
	EndpointMethodGet EndpointMethod = http.MethodGet
)

func (e *EndpointAPIModel) NewRequest(value ValueGetter) (*http.Request, error) {
	host, err := e.PopulateHost(value)
	if err != nil {
		return nil, ErrInvalidParam.Wrap(err, "populate host")
	}

	r, err := http.NewRequest(string(e.Method), fmt.Sprintf("//%s", host), nil)
	if err != nil {
		return nil, ErrInvalidParam.Wrap(err, "new request")
	}

	// we can put param and value together at first
	pValues := newParamValues(e.PathParams, value)
	path, err := e.PopulatePath(pValues)
	if err != nil {
		return nil, ErrInvalidParam.Wrap(err, "populate path")
	}
	r.URL.Path = path

	qValues := newParamValues(e.QueryParams, value)
	rawQuery, err := e.EncodeQuery(qValues)
	if err != nil {
		return nil, ErrInvalidParam.Wrap(err, "encode queries")
	}
	r.URL.RawQuery = rawQuery

	return r, nil
}

func (e *EndpointAPIModel) PopulateHost(value ValueGetter) (string, error) {
	return e.Host.Transform(value.Get(e.Host.Name))
}

var ParamRegexp *regexp.Regexp = regexp.MustCompile(`\{(\w+)\}`)

func (e *EndpointAPIModel) PopulatePath(pvs paramValues) (string, error) {
	var returnErr error
	replacedPath := e.Path
	replacedPath = ParamRegexp.ReplaceAllStringFunc(replacedPath, func(s string) string {
		if returnErr != nil {
			return s
		}

		key := ParamRegexp.ReplaceAllString(s, "${1}")
		pv, ok := pvs.Find(key)
		// means the param can be found in the endpoint path, but not in the endpoint param
		if !ok {
			returnErr = ErrMissingRequiredParam.New("path: %s, param: %s", e.Path, key)
			return s
		}

		val, err := pv.TransformedValue()
		if err != nil {
			returnErr = err
			return s
		}

		return val
	})
	return replacedPath, returnErr
}

func (e *EndpointAPIModel) EncodeQuery(pvs paramValues) (string, error) {
	query := url.Values{}
	for _, q := range e.QueryParams {
		// cuz paramValues was generated by e.Query, paramValues can always find param by q.Name
		pv, _ := pvs.Find(q.Name)
		val, err := pv.TransformedValue()
		if err != nil {
			return "", err
		}
		query.Add(q.Name, val)
	}
	return query.Encode(), nil
}

type paramValues map[string]paramValue

func newParamValues(params []EndpointAPIParam, value ValueGetter) paramValues {
	pvs := paramValues{}
	for _, p := range params {
		pvs[p.Name] = paramValue{Param: p, RawValue: value.Get(p.Name)}
	}
	return pvs
}

func (v paramValues) Find(key string) (paramValue, bool) {
	pv, ok := v[key]
	return pv, ok
}

type paramValue struct {
	Param    EndpointAPIParam
	RawValue string
}

func (pv *paramValue) TransformedValue() (string, error) {
	return pv.Param.Transform(pv.RawValue)
}

type EndpointAPIParam struct {
	Name string `json:"name"`
	// represents what param is
	Model                EndpointAPIParamModel `json:"model"`
	PreModelTransformer  ModelTransformer      `json:"-"`
	PostModelTransformer ModelTransformer      `json:"-"`
}

// Transform incoming param's value by transformer at endpoint / model definition
func (p *EndpointAPIParam) Transform(value string) (string, error) {
	transfomers := []ModelTransformer{
		p.PreModelTransformer,
		p.Model.Transformer,
		p.PostModelTransformer,
	}

	for _, t := range transfomers {
		if t == nil {
			continue
		}
		v, err := t(value)
		if err != nil {
			return "", err
		}
		value = v
	}

	return value, nil
}

// Transformer can transform the incoming param's value in special scenarios
// Also, now are used as validation function
type ModelTransformer func(value string) (string, error)

type EndpointAPIParamModel struct {
	Type        string           `json:"type"`
	Transformer ModelTransformer `json:"-"`
}
