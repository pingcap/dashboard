// Copyright 2021 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package schema

import (
	"fmt"
	"net/http"
	"net/url"
	"regexp"

	"github.com/joomcode/errorx"

	"github.com/pingcap/tidb-dashboard/pkg/apiserver/model"
)

var (
	ErrNS                  = errorx.NewNamespace("error.api.debugapi.endpoint")
	ErrPathParamNotMatched = ErrNS.NewType("path_param_not_matched")
	ErrValueTransformed    = ErrNS.NewType("error_value_transformed")
)

type EndpointAPI struct {
	ID        string             `json:"id"`
	Component model.NodeKind     `json:"component"`
	Path      string             `json:"path"`
	Method    string             `json:"method"`
	Host      EndpointAPIParam   `json:"host"`
	Segment   []EndpointAPIParam `json:"segment"` // e.g. /stats/dump/{db}/{table} -> db, table
	Query     []EndpointAPIParam `json:"query"`   // e.g. /debug/pprof?seconds=1 -> seconds
}

func (e *EndpointAPI) Populate(req *http.Request, values url.Values) error {
	newReq, err := e.NewRequest(values)
	if err != nil {
		return err
	}
	req.URL = newReq.URL
	return nil
}

func (e *EndpointAPI) NewRequest(values url.Values) (*http.Request, error) {
	host, err := e.PopulateHost(values)
	if err != nil {
		return nil, err
	}

	r, err := http.NewRequest(e.Method, host, nil)
	if err != nil {
		return nil, err
	}

	// we can put param and value together at first
	pValues := newParamValues(e.Segment, values)
	path, err := e.PopulatePath(pValues)
	if err != nil {
		return nil, err
	}
	r.URL.Path = path

	qValues := newParamValues(e.Query, values)
	rawQuery, err := e.EncodeQuery(qValues)
	if err != nil {
		return nil, err
	}
	r.URL.RawQuery = rawQuery

	return r, nil
}

func (e *EndpointAPI) PopulateHost(values url.Values) (string, error) {
	return e.Host.Transform(values.Get(e.Host.Name))
}

var ParamRegexp *regexp.Regexp = regexp.MustCompile(`\{(\w+)\}`)

func (e *EndpointAPI) PopulatePath(pvs paramValues) (string, error) {
	var returnErr error
	replacedPath := e.Path
	replacedPath = ParamRegexp.ReplaceAllStringFunc(replacedPath, func(s string) string {
		if returnErr != nil {
			return s
		}

		key := ParamRegexp.ReplaceAllString(s, "${1}")
		pv, ok := pvs.Find(key)
		// means the param can be found in the endpoint path, but not in the endpoint param
		if !ok {
			returnErr = ErrPathParamNotMatched.New("path: %s, param: %s", e.Path, key)
			return s
		}

		val, err := pv.TransformedValue()
		if err != nil {
			returnErr = err
			return s
		}

		return val
	})
	return replacedPath, returnErr
}

func (e *EndpointAPI) EncodeQuery(pvs paramValues) (string, error) {
	query := url.Values{}
	for _, q := range e.Query {
		// cuz paramValues was generated by e.Query, paramValues can always find param by q.Name
		pv, _ := pvs.Find(q.Name)
		val, err := pv.TransformedValue()
		if err != nil {
			return "", err
		}
		query.Add(q.Name, val)
	}
	return query.Encode(), nil
}

type paramValues map[string]paramValue

func newParamValues(params []EndpointAPIParam, values url.Values) paramValues {
	pvs := paramValues{}
	for _, p := range params {
		pvs[p.Name] = paramValue{Param: p, RawValue: values.Get(p.Name)}
	}
	return pvs
}

func (v paramValues) Find(key string) (paramValue, bool) {
	pv, ok := v[key]
	return pv, ok
}

type paramValue struct {
	Param    EndpointAPIParam
	RawValue string
}

func (pv *paramValue) TransformedValue() (string, error) {
	return pv.Param.Transform(pv.RawValue)
}

type EndpointAPIParam struct {
	Name   string `json:"name"`
	Prefix string `json:"prefix"`
	Suffix string `json:"suffix"`
	// represents what param is
	Model                EndpointAPIModel `json:"model"`
	PreModelTransformer  ModelTransformer `json:"-"`
	PostModelTransformer ModelTransformer `json:"-"`
}

func (p *EndpointAPIParam) Transform(value string) (string, error) {
	transfomers := []ModelTransformer{
		p.PreModelTransformer,
		p.Model.Transformer,
		p.PostModelTransformer,
	}

	for _, t := range transfomers {
		if t == nil {
			continue
		}
		v, err := t(value)
		if err != nil {
			return "", err
		}
		value = v
	}

	return fmt.Sprintf("%s%s%s", p.Prefix, value, p.Suffix), nil
}

type ModelTransformer func(value string) (string, error)

type EndpointAPIModel struct {
	Type        string           `json:"type"`
	Transformer ModelTransformer `json:"-"`
}
